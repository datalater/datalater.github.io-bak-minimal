[ { "title": "화폐 예제 실습으로 TDD의 리듬 느껴보기 - 4. 프라이버시", "url": "/posts/tdd-currency-4/", "categories": "TIL, TDD", "tags": "tdd, tdd-by-example", "date": "2022-06-08 00:00:00 +0900", "snippet": "💁 프롤로그 시리즈 “화폐 예제 실습으로 TDD의 리듬 느껴보기“에서 사용되는 공통 프롤로그입니다.graph LR A[?] --&amp;gt; B[Clean code that works]어떻게 하면 작동하는 깔끔한 코드(clean code that works)를 얻을 수 있을까요? 켄트 벡(Kent Beck)은 자동화된 테스트로 개발을 이끌어 가는 테스트 주도 개발(TDD, Test Driven Development)을 제안합니다. 과연 TDD를 하면 작동하는 깔끔한 코드를 얻을 수 있는지, 어떤 이유로 그러한지 궁금하네요. 책 테스트 주도 개발(Test Driven Development: By Example)을 읽고 실습한 내용을 정리합니다. 실습 코드 회고 TDD 시작하기 TDD는 두 가지 규칙을 따릅니다: 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다. 중복을 제거한다. 위 규칙에 의해 TDD로 코드를 짜는 순서는 다음과 같이 결정됩니다. 레드(RED) - 실패하는 작은 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다. 그린(GREEN) - 빨리 테스트가 통과하게끔 만든다. 이를 위해 어떤 죄악을 저질러도 좋다. 리팩토링(REFACTOR) - 일단 테스트를 통과하게만 하는 와중에 생겨난 모든 중복을 제거한다. 죄악이란 기존 코드 복사해서 붙이기(copy and paste), 테스트만 간신히 통과할 수 있게끔 함수가 무조건 특정 상수를 반환하도록 구현하기 등을 의미한다. graph LR A[&quot;🔴 RED&quot;] --&amp;gt;B B[&quot;🟢 GREEN&quot;] --&amp;gt;C C[&quot;🔵 REFACTOR&quot;] --&amp;gt;A 리팩토링(Refactoring)이란 코드의 외적 행위는 그대로 유지하면서 내부 구조를 변경하는 작업을 뜻한다. 화폐 예제의 목표 화폐 예제를 실습하면서 가져야 할 목표는 TDD의 리듬을 느껴보는 것입니다. 내 목표는 여러분이 테스트 주도 개발(TDD)의 리듬을 보도록 하는 것이다. 그 리듬은 다음과 같이 요약할 수 있다. 재빨리 테스트를 하나 추가한다. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다. 코드를 조금 바꾼다. 모든 테스트를 실행하고 전부 성공하는지 확인한다. 리팩토링을 통해 중복을 제거한다. 아마 당신은 다음과 같은 것에 대해 놀랄 것이다. 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지 새 테스트를 돌아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지 얼마나 자주 테스트를 실행하는지 얼마나 수없이 작은 단계를 통해 리팩토링이 되어가는지 1 이 예제를 통해 여러분은 코딩하기 전에 먼저 테스트를 만드는 법과 설계를 유기적으로 키워나가는(grow) 방법을 배우게 될 것이다. 2 화폐 예제 요구사항 AS-IS에서 TO-BE로 변경하는 것이 화폐 예제의 요구사항입니다. AS-IS 다음과 같은 보고서가 있다. 종목 주 가격 합계 IBM 1000 25 2500 GE 400 100 40000     합계 65000 TO-BE 다중 통화를 지원하는 보고서를 만들어야 한다. 환율을 명시해야 한다. 종목 주 가격 합계 IBM 1000 25USD 2500USD GE 400 100CHF 40000CHF     합계 65000USD 기준 변환 환율 CHF USD 1.5 할일 목록 읽는 법 $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기- Dollar 부작용(side effect)? Money 반올림? 일반: 작업해야 할 항목 빨강: 현재 작업을 시작한 항목 초록: 작업을 끝낸 항목 🎬 4장 프라이버시 3지난 할일 목록 $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10- amount를 private으로 만들기+ Dollar 부작용(side effect)? Money 반올림?+ equals() hashCode() Equal null Equal Object +: 완료된 항목 -: 지금 진행할 항목지난 코드class Dollar { amount: number; constructor(amount) { this.amount = amount; } times(multiplier: number) { return new Dollar(this.amount * multiplier); } equals(other: Dollar) { return this.amount === other.amount; }}test(&quot;곱하기&quot;, () =&amp;gt; { const five: Dollar = new Dollar(5); let product: Dollar; product = five.times(2); expect(product.amount).toBe(10); product = five.times(3); expect(product.amount).toBe(15);});test(&quot;값 동치성&quot;, () =&amp;gt; { expect(new Dollar(5).equals(new Dollar(5))).toBe(true); expect(new Dollar(5).equals(new Dollar(6))).toBe(false);});테스트가 정확히 말하고 있는가(지침) 앞에서 equals()를 구현해서 동치성 문제를 정의했으므로 이를 이용하여 테스트가 조금 더 많은 이야기를 해줄 수 있도록 만드세요.(목표) 개념적으로 Dollar.times() 연산은 호출을 받은 객체의 값에 인자로 받은 곱수만큼 곱한 값을 갖는 Dollar를 반환해야 합니다.(문제) 현재 테스트는 그것을 정확히 말하지 않습니다.product = five.times(2);expect(product.amount).toBe(10);(해결) 첫 번째 단언(assertion)을 Dollar와 Dollar를 비교하는 것으로 재작성합니다.product = five.times(2);expect(product).toBe(new Dollar(10));(적용) 두 번째 단언도 마찬가지로 고칩니다.product = five.times(2);expect(product).toBe(new Dollar(10));product = five.times(3);expect(product).toBe(new Dollar(15));임시 변수인 product가 쓸모없어 보이므로 인라인시킵니다.test(&quot;곱하기&quot;, () =&amp;gt; { const five: Dollar = new Dollar(5); expect(five.times(2)).toBe(new Dollar(10)); expect(five.times(3)).toBe(new Dollar(15));});이 테스트는 일련의 오퍼레이션이 아니라 참인 명제에 대한 단언들이므로 우리의 의도를 더 명확하게 이야기해줍니다.(리팩터) 테스트를 고치고 나니 이제 Dollar의 amount 인스턴스 변수를 사용하는 코드는 Dollar 자신밖에 없게 됐습니다. 따라서 변수를 private으로 변경할 수 있습니다.class Dollar { private amount: number; constructor(amount) { this.amount = amount; } times(multiplier: number) { return new Dollar(this.amount * multiplier); } equals(other: Dollar) { return this.amount === other.amount; }} $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10+ amount를 private으로 만들기+ Dollar 부작용(side effect)? Money 반올림?+ equals() hashCode() Equal null Equal ObjectTDD를 하면서 적극적으로 관리해야 할 위험 요소동치성 테스트가 통과되었습니다. 그러나 동치성 테스트가 동치성에 대한 코드가 정확히 작동한다는 것을 검증하는 데 실패한다면, 곱하기 테스트 역시 곱하기에 대한 코드가 정확하게 작동한다는 것을 검증하는 데 실패하게 됩니다. 이것은 TDD를 하면서 적극적으로 관리해야 할 위험 요소입니다.우리는 완벽함을 위해 노력하지는 않는다(주의) TDD를 하면서 우리는 완벽함을 위해 노력하지 않습니다. 모든 것을 두 번 말함으로써(코드와 테스트로 한 번씩) 자신감을 가지고 전진할 수 있을 만큼만 결함의 정도를 낮추기를 희망할 뿐입니다. (문제) 때떄로 우리의 추론이 맞지 않아서 결함이 손가락 사이로 빠져나가는 수가 있습니다. (대처) 그럴 때면 테스트를 어떻게 작성해야 했는지에 대한 교훈을 얻고 다시 앞으로 나아갑니다.지금까지 배운 것 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다. 두 테스트가 동시에 실패하면 망한다는 점을 인식했다. 위험 요소가 있음에도 계속 진행했다. 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 사용했다.📚 함께 읽기 테스트 주도 개발 실습 코드 - 4장 프라이버시 회고🔖 주석 테스트 주도 개발. 1부. 38쪽. &amp;#8617; 테스트 주도 개발. 들어가는 글. 27쪽. &amp;#8617; 테스트 주도 개발. 4장. 65쪽. &amp;#8617; " }, { "title": "화폐 예제 실습으로 TDD의 리듬 느껴보기 - 3. 모두를 위한 평등", "url": "/posts/tdd-currency-3/", "categories": "TIL, TDD", "tags": "tdd, tdd-by-example, 값객체패턴", "date": "2022-04-05 00:00:00 +0900", "snippet": "💁 프롤로그 시리즈 “화폐 예제 실습으로 TDD의 리듬 느껴보기“에서 사용되는 공통 프롤로그입니다.graph LR A[?] --&amp;gt; B[Clean code that works]어떻게 하면 작동하는 깔끔한 코드(clean code that works)를 얻을 수 있을까요? 켄트 벡(Kent Beck)은 자동화된 테스트로 개발을 이끌어 가는 테스트 주도 개발(TDD, Test Driven Development)을 제안합니다. 과연 TDD를 하면 작동하는 깔끔한 코드를 얻을 수 있는지, 어떤 이유로 그러한지 궁금하네요. 책 테스트 주도 개발(Test Driven Development: By Example)을 읽고 실습한 내용을 정리합니다. 실습 코드 회고 TDD 시작하기 TDD는 두 가지 규칙을 따릅니다: 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다. 중복을 제거한다. 위 규칙에 의해 TDD로 코드를 짜는 순서는 다음과 같이 결정됩니다. 레드(RED) - 실패하는 작은 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다. 그린(GREEN) - 빨리 테스트가 통과하게끔 만든다. 이를 위해 어떤 죄악을 저질러도 좋다. 리팩토링(REFACTOR) - 일단 테스트를 통과하게만 하는 와중에 생겨난 모든 중복을 제거한다. 죄악이란 기존 코드 복사해서 붙이기(copy and paste), 테스트만 간신히 통과할 수 있게끔 함수가 무조건 특정 상수를 반환하도록 구현하기 등을 의미한다. graph LR A[&quot;🔴 RED&quot;] --&amp;gt;B B[&quot;🟢 GREEN&quot;] --&amp;gt;C C[&quot;🔵 REFACTOR&quot;] --&amp;gt;A 리팩토링(Refactoring)이란 코드의 외적 행위는 그대로 유지하면서 내부 구조를 변경하는 작업을 뜻한다. 화폐 예제의 목표 화폐 예제를 실습하면서 가져야 할 목표는 TDD의 리듬을 느껴보는 것입니다. 내 목표는 여러분이 테스트 주도 개발(TDD)의 리듬을 보도록 하는 것이다. 그 리듬은 다음과 같이 요약할 수 있다. 재빨리 테스트를 하나 추가한다. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다. 코드를 조금 바꾼다. 모든 테스트를 실행하고 전부 성공하는지 확인한다. 리팩토링을 통해 중복을 제거한다. 아마 당신은 다음과 같은 것에 대해 놀랄 것이다. 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지 새 테스트를 돌아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지 얼마나 자주 테스트를 실행하는지 얼마나 수없이 작은 단계를 통해 리팩토링이 되어가는지 1 이 예제를 통해 여러분은 코딩하기 전에 먼저 테스트를 만드는 법과 설계를 유기적으로 키워나가는(grow) 방법을 배우게 될 것이다. 2 화폐 예제 요구사항 AS-IS에서 TO-BE로 변경하는 것이 화폐 예제의 요구사항입니다. AS-IS 다음과 같은 보고서가 있다. 종목 주 가격 합계 IBM 1000 25 2500 GE 400 100 40000     합계 65000 TO-BE 다중 통화를 지원하는 보고서를 만들어야 한다. 환율을 명시해야 한다. 종목 주 가격 합계 IBM 1000 25USD 2500USD GE 400 100CHF 40000CHF     합계 65000USD 기준 변환 환율 CHF USD 1.5 할일 목록 읽는 법 $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기- Dollar 부작용(side effect)? Money 반올림? 일반: 작업해야 할 항목 빨강: 현재 작업을 시작한 항목 초록: 작업을 끝낸 항목 🎬 3장 모두를 위한 평등 3 🚀 TL;DR 디자인 패턴(값 객체)이 하나의 또 다른 오퍼레이션(값 동치성)을 암시한다. 설계를 어떻게 해야 할지, 프로그램이 어떻게 변화할지 감이 잡히지 않을 때는 삼각측량을 사용하면 다른 방향으로 생각해볼 기회를 준다. 삼각측량을 사용하려면 이미 존재하는 테스트 케이스에 추가적으로 일반적인 해를 필요로 하는 테스트 케이스를 추가하면 된다. 지난 할일 목록 $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기+ Dollar 부작용(side effect)? Money 반올림?값 객체가 암시하는 것 값 객체가 암시하는 것 중 하나는 2장에서와 같이 모든 연산은 새 객체를 반환해야 한다는 것이다. 또다른 암시는 값 객체는 equals()를 구현해야 한다는 것인데, 왜냐하면 $5라는 것은 항상 다른 $5만큼이나 똑같이 좋은 것이기 때문이다. 만약 Dollar를 해시 테이블의 키로 쓸 생각이라면 equals()를 구현할 때 hashCode()를 같이 구현해야 한다. 이것을 할일 목록에 적어 놓고 이것 때문에 문제가 생기면 그때 다루도록 하자. $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기+ Dollar 부작용(side effect)? Money 반올림?- equals() hashCode()값 객체가 동일한 값인지 알기 위해서 equals()라는 함수를 작성할 것입니다. 이때 값 객체의 내부 메서드로 equals()를 구현합니다. 왜 이렇게 할까요? 우리가 만들려고 하는 Dollar 객체는 화폐 도메인에서 특정 조건을 만족하는 타입을 가진 값이므로 이럴 때 사용하는 값 객체 패턴을 활용하기 위해서입니다. 값 객체에 대한 설명은 아래 내용을 참고합니다. 값 객체란 무엇인가 참조 - VO(Value Object)란? (질문) 값 객체를 언제, 왜 사용할까? (답변) 어떤 도메인의 (변하지 않는) “값”을 사용하려고 하는데 primitive 타입이 적절하지 않을 때 사용한다. 예를 들어, 나이를 나타낼 때 다음 중 어떤 변수 타입을 사용해야 할까? Integer Boolean String 셋 다 아니다. 애초에 나이는 Integer가 아닐 뿐더러, 생각해보면 Integer는 나이가 가지지 않는 속성과 연산을 가지고 있다. 두 나이를 더하거나 빼는 것이 말이 되는가? 아마도. 두 나이를 곱하거나 나누는 것이 말이 되는가? 말이 안 된다. 음수 나이를 허용하는 게 말이 되는가? 말이 안된다. 이렇게 값을 나타내는 도메인 객체를 사용하려고 하는데 primitive 타입으로 충족이 되지 않을 때 값 객체 패턴(Value Object Pattern)을 사용하면 쉽게 해결할 수 있다. (특성) primitive 타입이 아니면서 값을 나타내려면 그 객체는 여러 가지 특성이 필요하다. 유효한 값인지 알아야 한다. 즉, 변수에 할당하기 전에 적절한 값이 될 수 있는지에 대한 유효성 검사 로직이 필요하다. (변하지 않는 값을 사용하려는 것이 전제이므로) 나중에 변경되지 않는 값이라는 것을 보장해야 한다. 이러한 특성을 가진 객체를 값 객체(Value Object)라고 한다. (정리) 값 객체는 특정 도메인에 적절한 타입을 가진 값을 나타내는 객체이다. 그리고 값 객체의 특징은 불변성(immutability), 값 동치성(equality), 자가 유효성 검사(self validation)이 있다. 불변성: 수정 메서드 setter가 없다. 값 동치성: 내부 값이 같은지 확인할 수 있다. 자가 유효성 검사: 생성자에서 유효한 값인지 검사한다. 따라서, 값 객체 내부에 값 동치성을 확인할 수 있는 equals() 메서드를 테스트 코드로 나타냅니다.test(&quot;equals&quot;, () =&amp;gt; { expect(new Dollar(5).equals(new Dollar(5))).toBe(true);});테스트 코드를 가장 빠르게 통과시키기 위해 가짜로 구현하는 방법은 단순히 true를 반환하는 것입니다.class Dollar { amount: number; constructor(amount) { this.amount = amount; } times(multiplier: number) { return new Dollar(this.amount * multiplier); } equals(other: Dollar): boolean { return true; }}true는 어떻게 나오는 값일까요? 우리 둘 다 사실은 true가 ‘5 === 5’라는 것을 알고, 이것은 다시 ‘amount === 5’이며, 결국은 ‘amount === dollar.amount’임을 안다. 만약 이런 단계를 밟아간다면, 나는 가장 신중한 세 번째 방법인 삼각측량 전략을 보여주지 못하게 될 것 같다.삼각측량을 사용하여 코드를 일반화하여 테스트 코드를 통과시키는 방법 만약 라디오 신호를 두 수신국이 감지하고 있을 때, 수신국 사이의 거리가 알려져 잇고 각 수신국이 신호의 방향을 알고 있다면, 이 정보들만으로 충분히 신호의 거리와 방위를 알 수 있다. 이 계산 법을 삼각측량이라고 한다. 삼각측량을 이용하려면 예제가 두 개 이상 있어야만 코드를 일반화할 수 있다. 테스트 코드와 모델 코드 사이의 중복(true)을 잠깐만 무시하자. 두 번째 예가 좀더 일반적인 해를 필요로 할 때, 오로지 그때만 비로소 일반화한다.삼각측량을 사용하기 위해서 일반적인 해를 필요로 하는 두 번째 테스트 케이스($5 !== $6)를 추가합니다.test(&quot;equals&quot;, () =&amp;gt; { expect(new Dollar(5).equals(new Dollar(5))).toBe(true); expect(new Dollar(5).equals(new Dollar(6))).toBe(false);});테스트를 통과시키기 위해 동치성이 일반적인 상황에서도 모두 동작하는 코드를 구현합니다.class Dollar { amount: number; constructor(amount) { this.amount = amount; } times(multiplier: number) { return new Dollar(this.amount * multiplier); } equals(other: Dollar): boolean { return this.amount === other.amount; }} $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기+ Dollar 부작용(side effect)? Money 반올림?+ equals() hashCode()항상 삼각측량을 사용할 필요는 없습니다. 해법이 보이면 그 방법대로 구현하면 됩니다. 나는 어떻게 리팩토링해야 하는지 전혀 감이 안 올때만 삼각측량을 사용한다. 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현한다.하지만 설계를 어떻게 해야 할지 감이 잡히지 않을 때 다른 방향으로 생각해볼 기회를 준다는 점에서는 유용합니다. 그러나 설계를 어떻게 할지 떠오르지 않을 때면, 삼각측량은 문제를 조금 다른 방향에서 생각해볼 기회를 제공한다. 지금 설계하는 프로그램이 어떤 변화 가능성을 지원해야 하는가? 몇몇 부분을 변경시켜보면 답이 좀 명확해질 것이다.널 값이나 다른 객체들과 값 비교하기동일성 문제는 해결됐지만 널 값이나 다른 객체들과 비교하면 어떻게 될까요? 이런 상황은 일반적이긴 하지만, 지금 당장은 필요하지 않다. 따라서 할일 목록에 적어두기만 하자.지금 당장 필요하지 않으므로 할일 목록에만 적어둡니다. $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기+ Dollar 부작용(side effect)? Money 반올림?+ equals() hashCode() Equal null Equal object정리 이제 동질성 기능을 구현했으므로 Dollar와 Dollar를 직접 비교할 수 있게 됐다. 따라서 모든 올바른 인스턴스 변수들이 그렇듯 amount를 private으로 만들 수 있게 됐다. 위 내용들을 검토해보자. 우리는 우리의 디자인 패턴(값 객체)이 하나의 또 다른 오퍼레이션(값 동치성)을 암시한다는 것을 알아챘다. 해당 오퍼레이션을 테스트했다. 해당 오퍼레이션을 간단히 구현했다. 곧장 리팩토링하는 대신 테스트를 조금 더 했다. (삼각측량을 위해) 두 경우를 모두 수용할 수 있도록 리팩토링 했다. 📚 함께 읽기 테스트 주도 개발 실습 코드 - 3장 모두를 위한 평등 회고🔖 주석 테스트 주도 개발. 1부. 38쪽. &amp;#8617; 테스트 주도 개발. 들어가는 글. 27쪽. &amp;#8617; 테스트 주도 개발. 3장. 59쪽. &amp;#8617; " }, { "title": "첫 셸 스크립트 만들기 (feat. 자동 로깅 스크립트)", "url": "/posts/first-shell-script/", "categories": "TIL, Opensource", "tags": "shell, bash, log", "date": "2022-03-26 00:00:00 +0900", "snippet": "💁 설명요새 15분 동안 다양한 주제의 문서를 읽고 요약하는 시간을 갖고 있습니다. 주제별로 디렉토리 구조를 만들어서 정리하고 있어요. 그런데 개별 파일을 분류할 때는 편하지만, 그동안 무엇을 읽고 어떤 파일을 작성했는지 전체를 한눈에 파악하기는 어려웠습니다. 문서를 추가하거나 수정할 때마다 자동으로 로깅을 해주면 좋겠다는 생각이 들었습니다.그래서 처음으로 셸 스크립트를 작성해서 자동 로깅을 구현했습니다. 문서를 수정할 때마다 로깅 파일을 남기는 셸 스크립트를 작성하고, pre-commit 훅으로 셸 스크립트를 자동 실행하는 과정을 정리합니다.요구사항 정리자동 로깅 스크립트- [ ] git 명령어로 현재 스테이징된 파일 목록을 가져온다.- [ ] 스테이징된 파일에서 첫번째 줄을 읽어서 원문 링크와 요약 파일 링크를 가져온다.- [ ] 가져온 데이터를 사용해서 마크다운 테이블의 로우(row)로 만든다.- [ ] 로우가 1개 이상이면 LOG.md 파일에 추가(append)한다.pre-commit 훅- [ ] 자동 로깅 스크립트를 실행하는 pre-commit 훅을 만든다.- [ ] pre-commit 훅이 프로젝트 저장소에 저장되도록 설정한다.셸 스크립트 기본 문법 파악하기 참조 - Shell Scripting Tutorial변수#!/bin/sh# 사용자 입력을 받아서 변수에 저장하고 변수 값으로 파일 만들기echo &quot;What is your name?&quot;read USER_NAMEecho &quot;Hello $USER_NAME&quot;echo &quot;I will create you a file called ${USER_NAME}_file&quot;touch &quot;${USER_NAME}_file&quot;반복문#!/bin/sh# bye라고 입력할 때까지 반복INPUT_STRING=hellowhile [ &quot;$INPUT_STRING&quot; != &quot;bye&quot; ]do echo &quot;Please type something in (bye to quit)&quot; read INPUT_STRING echo &quot;You typed: $INPUT_STRING&quot;done# 명시한 내용으로 반복for i in hello 1 * 2 goodbyedo echo &quot;Looping ... i is set to $i&quot;done# Looping ... i is set to hello# Looping ... i is set to 1# Looping ... i is set to 101.md# Looping ... i is set to first.sh# Looping ... i is set to 2# Looping ... i is set to goodbye## *는 현재 스크립트를 실행하는 디렉토리 내부에 있는 모든 파일을 가져온다.# new line이 들어간 문자열 변수로 반복files=&quot;LOG.md\\nfrontend/css-layout-algorithm.md\\nlog.sh&quot;echo &quot;$files&quot; | while IFS= read -r filename; do if ! [[ -z &quot;$filename&quot; ]]; then echo &quot;- $filename&quot; fidone조건문#!/bin/sh# 조건문 구조if [ something ]; then echo &quot;Something&quot; elif [ something_else ]; then echo &quot;Something else&quot; else echo &quot;None of the above&quot;fi# 비교if [ &quot;$X&quot; -lt &quot;0&quot; ]; then echo &quot;X is less than zero&quot;fiif [ &quot;$X&quot; -gt &quot;0&quot; ]; then echo &quot;X is more than zero&quot;fiif [ -z &quot;$var&quot; ]; then echo &quot;\\$var is empty&quot;else echo &quot;\\$var is NOT empty&quot;fi# &amp;amp;&amp;amp;과 ||으로 조건문 짧게 쓰기[ &quot;$X&quot; -le &quot;0&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is less than or equal to zero&quot;[ &quot;$X&quot; -ge &quot;0&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is more than or equal to zero&quot;[ &quot;$X&quot; = &quot;0&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is the string or number \\&quot;0\\&quot;&quot;[ &quot;$X&quot; = &quot;hello&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X matches the string \\&quot;hello\\&quot;&quot;[ &quot;$X&quot; != &quot;hello&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is not the string \\&quot;hello\\&quot;&quot;[ -n &quot;$X&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is of nonzero length&quot;[ -f &quot;$X&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is the path of a real file&quot; || \\ echo &quot;No such file: $X&quot;[ -x &quot;$X&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is the path of an executable file&quot;[ &quot;$X&quot; -nt &quot;/etc/passwd&quot; ] &amp;amp;&amp;amp; \\ echo &quot;X is a file which is newer than /etc/passwd&quot;완성된 코드log.sh#!/bin/sh# Only Added(A) files in git (Not modified files)files=$(git diff --cached --name-only --diff-filter=A)if ! [[ -z &quot;$files&quot; ]]; then echo &quot;Added files:&quot; echo &quot;$files&quot; | while IFS= read -r filename; do if ! [[ -z &quot;$filename&quot; ]]; then echo &quot;- $filename&quot; fi done echo &quot;&quot;fi# Create LOG.md if it doesn&#39;t existif ! [[ -f &quot;LOG.md&quot; ]]; thencat &amp;gt; LOG.md &amp;lt;&amp;lt;- EOF# 📜 LOG| Last modified | Article | Summary || --- | --- | --- |EOFfi# Make table rows as looping through filesrows=&quot;&quot;newline=$&#39;\\n&#39;echo &quot;$files&quot; | while IFS= read -r filename; do # Skip if file is not markdown if ! [[ $filename == *.md ]]; then continue fi if [[ $filename == LOG.md || $filename == README.md ]]; then continue fi headline=$(git blame -L 1,1 $filename) if ! [[ -z $headline ]]; then last_modified=$(git blame $filename | grep -Eo &#39;\\b[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}\\b&#39; | sort -n | tail -1) article=$(echo $headline | awk &#39;{split($0, array, &quot;# &quot;); print array[2]}&#39;) # Skip if file is already in LOG.md (we will log only the first time the file is added) alreadyExists=$(grep -Fc &quot;$article&quot; LOG.md) if [[ $alreadyExists -gt 0 ]]; then echo &quot;Skipping already existing $article...&quot; continue; fi row=&quot;| $last_modified | $article | [$filename](./$filename) |&quot; rows+=${row}${newline} fidone# Remove last new line for appending new rows next time script is runrows=${rows%${newline}}if ! [[ -z $rows ]]; then echo &quot;Rows: $rows&quot;fi# Append new rows to LOG.mdif ! [[ -z $rows ]]; thencat &amp;gt;&amp;gt; LOG.md &amp;lt;&amp;lt;- EOF$rowsEOFgit add LOG.mdfi# Remove file if LOG file is an initialized default filelc=$(wc -l LOG.md | awk &#39;{print $1}&#39;)defaultLines=4if ! [[ $lc -gt $defaultLines ]]; then rm LOG.mdfi스크립트에 실행 권한을 추가합니다.$ chmod +x script.shpre-commit hookgit으로 commit을 할 때마다 commit 전에 위 스크립트를 실행하도록 pre-commit 훅을 설정합니다.먼저 .git/hooks/pre-commit.sample 파일명을 변경합니다. 파일명 pre-commit.sample에서 .sample을 삭제하면 pre-commit 훅이 자동으로 실행되기 때문입니다.$ mv .git/hooks/pre-commit.sample .git/hooks/pre-commit이제 .git/hooks/pre-commit 파일을 수정합니다.#!/bin/shecho &quot;Running pre-commit hook...&quot;source ./log.sh pre-commit 파일은 .git/hooks/ 디렉토리 내부에 있지만 실행할 때는 프로젝트 루트 경로를 참조하므로 ../../setup.sh 같은 형태가 아닌 ./setup.sh로 작성하면 됩니다.git config를 프로젝트에 포함시키기.git 폴더에 있는 .git/hooks/pre-commit 파일은 프로젝트 저장소에 버전 관리되지 않습니다. 따라서 현재 컴퓨터에서는 pre-commit 훅이 동작하더라도 다른 컴퓨터에서 이 프로젝트를 클론하면 위에서 설정한 훅이 사라지게 됩니다. 훅 폴더를 새로 만들고 git config의 훅의 경로(core.hooksPath)가 새로 만든 폴더를 바라보도록 설정하겠습니다.# 1. 프로젝트 루트 경로에서 .git-hooks 폴더를 생성합니다md .git-hooks# 2. .git-hooks 폴더에 pre-commit 훅 파일을 생성합니다.cat &amp;gt; .git-hooks/pre-commit &amp;lt;&amp;lt;- EOF#!/bin/shecho &quot;Running pre-commit hook...&quot;source ./log.shEOF# 3. 스크립트에 실행 권한을 추가합니다.chmod +x .git-hooks/pre-commit# 4. git config 명령어로 hooks 경로가 .git-hooks 폴더를 바라보도록 설정합니다.git config core.hooksPath .git-hooks여기서 1~3번의 결과물은 프로젝트 파일로 포함되지만 4번 명령어는 프로젝트를 클론할 때마다 기억하고 반복해야 합니다. 스크립트로 작성하여 자동화하겠습니다.cat &amp;gt; setup.sh &amp;lt;&amp;lt;- EOF#!/bin/shgit config core.hooksPath .git-hooksEOF이제 명령어를 기억할 필요없이 source setup.sh를 실행하면 git config에서 hooks 경로가 .git-hooks 폴더를 바라보도록 설정됩니다. 바로 실행해줍시다.chmod +x setup.shsource setup.sh설정이 완료되었습니다. 전체 코드는 datalater/15를 참조해주세요.📚 함께 보기 우아한형제들 - 훅으로 Git에 훅 들어가기 Shell scripting tutorial stackoverflow - creating files with some content with shell script: here document 사용 예시 huammmm1 - here document와 here string에 대해서: here document 사용 예시 stackoverflow - get the latest date from a text file stackoverflow - how to call one shell script from another? stackoverflow - Git pre-commit hook : changed/added files: 스테이지에 추가된 파일 목록 보기 stackoverflow - how to test if string exists in a file with bash: 파일에 문자열 포함되어 있는지 확인하기 github - datalater/15" }, { "title": "LeetCode - Letter Combinations of a Phone Number (JavaScript)", "url": "/posts/dsalgo-letter-combinations/", "categories": "TIL, Algorithm", "tags": "알고리즘", "date": "2022-03-15 00:00:00 +0900", "snippet": "💁 설명LeetCode - 17. Letter Combinations of a Phone Number를 풀고 나서 겪었던 시행착오를 기록하고 머릿속에 있던 생각을 글로 정리하면서 복기해봅니다.DFS로 생각하기DFS를 연습하려고 풀었던 문제였습니다. 그래서 이 문제를 어떻게 하면 DFS로 풀이할 수 있는지 중점적으로 살펴보겠습니다.먼저 map을 만듭니다.var letterCombinations = function (digits) { const map = { 2: &quot;abc&quot;, 3: &quot;def&quot;, 4: &quot;ghi&quot;, 5: &quot;jkl&quot;, 6: &quot;mno&quot;, 7: &quot;pqrs&quot;, 8: &quot;tuv&quot;, 9: &quot;wxyz&quot;, };};만약 digits가 &quot;23&quot;으로 입력되었다면 기대되는 정답과 우리가 원하는 연산은 다음과 같습니다:Input: digits = &quot;23&quot;;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;];// digits 문자열에서 i번째에 해당하는 숫자를 꺼내서 해당 숫자에 맵핑되는 문자열을 반환합니다.digits[0] = 2 | &quot;abc&quot;digits[1] = 3 | &quot;def&quot;// 각 문자열을 모두 조합하는 형태로 탐색한 후 백트래킹하면서 결과를 조합합니다.[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]여기서 “각 문자열을 모두 조합하는 형태로 탐색한 후 백트래킹하면서 결과를 조합”하는 것을 for문으로 먼저 생각해보고 DFS 방식으로 바꿔보겠습니다.for (let i = 0; i &amp;lt; digits.length; i += 1) { // 0, 1 for (let j of map[digits[i]]) { // a, b, c | d, e, f /** * 첫번째 경우 * * i = 0, j = a * * a와 조합해야 하는 대상으로서 우리가 원하는 건 다음에 d가 오는 것이다. * 그런데 d, e, f는 i = 1일 때 등장하므로 다음 반복문으로 넘어가야 만날 수 있다. * * i에 대한 반복문으로 넘어가려면 지금까지 작성한 내용을 함수로 만들고 재귀호출하면 된다. * 그리고 i값을 1씩 증가시켜서 재귀호출하면 된다. * * 그러므로 dfs(i + 1)과 같은 형태로 호출하면 다음 반복문인 i = 1로 넘어간다. * 다만, i = 1이 되었을 때는 a값을 그대로 활용해야 하므로 이 값을 재귀호출할 때 인자로 넘겨줘야 한다. * 이때 인자로 통째로 넘겨주는 게 아니라 어차피 문자열을 조합하면 되니 a를 문자열에 추가한 형태로 넘겨주면 된다. * * dfs(i + 1, &quot;&quot; + j) * * 이 형식을 일반화한다. * * dfs(i + 1, path + j) */ }}var letterCombinations = function (digits) { const map = { 2: &quot;abc&quot;, 3: &quot;def&quot;, 4: &quot;ghi&quot;, 5: &quot;jkl&quot;, 6: &quot;mno&quot;, 7: &quot;pqrs&quot;, 8: &quot;tuv&quot;, 9: &quot;wxyz&quot;, }; function dfs(index, path) { for (let i = index; i &amp;lt; digits.length; i += 1) { for (let j of map[digits[i]]) { dfs(i + 1, path + j); } } } dfs(0, &quot;&quot;);};그런데 이렇게 하면 dfs가 종료되지 않고 끊임없이 호출되어 무한루프에 빠집니다. 재귀호출할 때는 항상 종료 조건을 떠올려야 합니다. 탐색을 모두 마치는 조건은 조합한 문자열의 길이가 digits의 길이와 같아지는 것입니다. 그리고 길이가 같아지면 조합한 문자열이 곧 우리가 원하는 결과물이므로 results 배열을 만들고 배열에 추가합니다.var letterCombinations = function (digits) { const map = { 2: &quot;abc&quot;, 3: &quot;def&quot;, 4: &quot;ghi&quot;, 5: &quot;jkl&quot;, 6: &quot;mno&quot;, 7: &quot;pqrs&quot;, 8: &quot;tuv&quot;, 9: &quot;wxyz&quot;, }; const result = []; function dfs(index, path) { if (path.length === digits.length) { result.push(path); return; } for (let i = index; i &amp;lt; digits.length; i += 1) { for (let j of map[digits[i]]) { dfs(i + 1, path + j); } } } dfs(0, &quot;&quot;); return result;};재귀함수의 프로세스 그려보기재귀 함수가 어떻게 동작하는지 머릿속으로 그려내려면 먼저 “언제 백트래킹을 하느냐”를 “종료 조건”과 함께 생각해보는 게 도움이 되는 것 같습니다. 종료 조건은 비교적 명확하고 간단하기 때문입니다. 위 코드의 경우 dfs 함수가 종료되면(즉, path의 길이가 완성되면), 백트래킹하여 중첩된 for문의 j값이 기존 값(ex. d)에서 다음 값(ex. e)으로 변경됩니다. 즉, 일반적인 그래프 탐색과 마찬가지로 모든 노드를 순회하다가 끝에 다다르면 가장 마지막 노드를 빼고 다른 노드를 탐색하는 것을 반복하는 프로세스입니다.종료 조건을 봤으니 시작 지점과 전체 흐름을 보겠습니다. 위 코드에서 루프에 대입되는 값을 적어보면 다음과 같습니다:// 시작dfs(0, &quot;&quot;)// 참고 값digits[0] = 2 | &quot;abc&quot;digits[1] = 3 | &quot;def&quot;// 전체 흐름| dfs(0, &quot;&quot;) | dfs(1, &quot;a&quot;) | dfs(1, &quot;a&quot;) | dfs(1, &quot;a&quot;) | dfs(0, &quot;&quot;) | || depth1 | depth2 | depth2 | depth2 | depth1 | || i = 0 | i = 1 | i = 1 | i = 1 | i = 0 | ... || j = a | j = d | j = e | j = e | j = b | || dfs(1, &quot;a&quot;) | dfs(2, &quot;ad&quot;) | dfs(2, &quot;ae&quot;) | dfs(2, &quot;af&quot;) | dfs(1, &quot;b&quot;) | || | 종료 후 백트래킹 | 종료 후 백트래킹 | 종료 후 백트래킹 | | |// 노드 탐색 순서[&quot;a&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]📚 함께 보기 LeetCode - 17. Letter Combinations of a Phone Number" }, { "title": "프로그래머스 - 메뉴 리뉴얼 (JavaScript)", "url": "/posts/dsalgo-menu-renewal/", "categories": "TIL, Algorithm", "tags": "알고리즘", "date": "2022-03-14 00:00:00 +0900", "snippet": "💁 설명프로그래머스 메뉴 리뉴얼 풀이를 설명합니다.문제 전략 세우기 문자열(“ABC”)로 특정 글자 길이(2)만큼 만들 수 있는 모든 조합(“AB”, AC”, BC”)을 만드는 함수를 만든다. 문자열 배열로 특정 글자 길이(2)만큼 만들 수 있는 모든 조합을 만드는 함수를 만든다. 배열에서 요소의 빈도를 계산해서 객체({AB: 2})로 만드는 함수를 만든다. 배열에서 빈도 수가 가장 많은 요소를 구하는 함수를 만든다. 단, 빈도 수가 동일할 경우 모두 선택해야 하므로 최빈값을 담은 배열로 리턴한다.위 내용을 간단한 할일 목록으로 정리합니다. 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;] 문자열 배열 조합 배열에서 요소의 빈도 수를 계산해서 객체로 만들기 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)TDD 테스트를 먼저 작성하고 테스트를 통과하도록 코드를 작성합니다.배열에서 요소의 빈도 수를 계산해서 객체로 만들기할일 목록에서 제일 간단해보이는 “배열에서 요소의 빈도 수를 계산해서 객체로 만들기”를 선택해서 테스트를 작성합니다. 실패하는 테스트 먼저 작성하겠다는 의미로 빨강색으로 표시합니다. 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;] 문자열 배열 조합- 배열에서 요소의 빈도 수를 계산해서 객체로 만들기 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)실패하는 테스트 코드를 작성합니다.test(&quot;배열에서 요소의 빈도 수를 계산해서 객체로 만든다&quot;, () =&amp;gt; { expect(count([&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;, &quot;AB&quot;])).toEqual({ AB: 2, AC: 1, BC: 1 });});테스트 코드를 통과하도록 코드를 작성합니다.function count(array) { return array.reduce((acc, cur) =&amp;gt; { acc[cur] = acc[cur] ? acc[cur] + 1 : 1; return acc; }, {});}배열의 요소가 객체에 이미 있으면 현재 값에 1을 더하고, 없으면 처음 등장한 것이므로 1을 넣습니다. 동일한 코드 function count(arr) { return arr.reduce((acc, cur) =&amp;gt; { acc[cur] = (acc[cur] || 0) + 1; return acc; }, {});} 완료되었으므로 테스트를 통과한다는 의미로 녹색으로 표시합니다. 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;] 문자열 배열 조합+ 배열에서 요소의 빈도 수를 계산해서 객체로 만들기 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)배열에서 최빈값 요소 구하기실패하는 테스트 먼저 작성하겠다는 의미로 빨강색으로 표시합니다. 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;] 문자열 배열 조합+ 배열에서 요소의 빈도 수를 계산해서 객체로 만들기- 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)실패하는 테스트 코드를 작성합니다.주의할 점: 최빈값 요소가 여러 개 있을 수 있으므로 배열로 리턴한다. 최빈값이 1이라면 빈 배열을 리턴한다. (문제의 조건: 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다)test(&quot;배열에서 최빈값 요소를 구한다&quot;, () =&amp;gt; { expect(mostFrequent([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;])).toEqual([&quot;A&quot;]); expect(mostFrequent([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])).toEqual([]); expect(mostFrequent([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;C&quot;])).toEqual([&quot;A&quot;, &quot;C&quot;]);});테스트 코드를 통과하도록 코드를 작성합니다.function mostFrequent(array) { const countMap = count(array); const max = Math.max(...Object.values(countMap)); return max &amp;gt; 1 ? Object.keys(countMap).filter((key) =&amp;gt; countMap[key] === max) : [];}문자열 조합실패하는 테스트 먼저 작성하겠다는 의미로 빨강색으로 표시합니다.- 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;] 문자열 배열 조합+ 배열에서 요소의 빈도 수를 계산해서 객체로 만들기+ 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)그런데 생각해보니 문자열로 조합하는 것보다 배열의 요소를 조합하는 것이 유사하지만 더 간단한 문제로 보입니다. 그래서 배열의 요소를 조합하는 문제를 할일 목록에 추가하고 현재 작업으로 시작하겠습니다. 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;] 문자열 배열 조합+ 배열에서 요소의 빈도 수를 계산해서 객체로 만들기+ 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)- 주어진 배열에서 특정 길이만큼 조합하기실패하는 테스트를 먼저 작성합니다.test(&quot;배열에서 특정 길이만큼 조합할 수 있는 모든 경우의 수를 구한다&quot;, () =&amp;gt; { expect(combinate([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], 2)).toEqual([ [&quot;A&quot;, &quot;B&quot;], [&quot;A&quot;, &quot;C&quot;], [&quot;B&quot;, &quot;C&quot;], ]);});테스트 코드를 통과하도록 코드를 작성합니다.function combinate(array, n) { const result = []; if (n === 1) { return array.map((it) =&amp;gt; [it]); } array.forEach((fixed, index, origin) =&amp;gt; { const rest = origin.slice(index + 1); const combinations = combinate(rest, n - 1); const concated = combinations.map((combination) =&amp;gt; [fixed, ...combination]); result.push(...concated); }); return result;} 코드 참조: 냥인의 블로그이제 다시 문자열 조합 문제로 돌아가겠습니다.- 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;] 문자열 배열 조합+ 배열에서 요소의 빈도 수를 계산해서 객체로 만들기+ 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)+ 주어진 배열에서 특정 길이만큼 조합하기실패하는 테스트 코드를 작성합니다.test(&quot;주어진 문자열에서 특정한 길이만큼 조합한다&quot;, () =&amp;gt; { expect(combinateString(&quot;ABC&quot;, 2)).toEqual([&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;]); expect(combinateString(&quot;ABCFG&quot;, 2)).toEqual([ &quot;AB&quot;, &quot;AC&quot;, &quot;AF&quot;, &quot;AG&quot;, &quot;BC&quot;, &quot;BF&quot;, &quot;BG&quot;, &quot;CF&quot;, &quot;CG&quot;, &quot;FG&quot;, ]);});테스트 코드를 통과하도록 코드를 작성합니다.function combinateString(s, n) { const _s = s.split(); const result = combinate(_s, n) .map((it) =&amp;gt; it.sort().join(&quot;&quot;)) .sort(); return result;}문자열을 베열로 만든 후에 조합을 구하고 다시 문자열로 합치기(join(&quot;&quot;)) 전에 항상 오름차순으로 정렬해야 합니다. 왜냐하면 주문 “AX”와 “XA”는 동일한 주문의 조합으로 처리해야 하기 때문입니다. 이 부분을 놓치면 조합을 카운트를 할 때 문제가 발생합니다. 그리고 최종 결과에서도 오름차순으로 정렬합니다. 왜냐하면 최종 결과에서 오름차순으로 정렬하여 리턴해야 하기 때문입니다.문자열 배열 조합+ 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;]- 문자열 배열 조합+ 배열에서 요소의 빈도 수를 계산해서 객체로 만들기+ 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)+ 주어진 배열에서 특정 길이만큼 조합하기이 문제는 문자열이 하나가 아니라 여러 개가 담긴 배열이 주어졌을 때 전체 문자열에서 특정 길이만큼 조합하는 문제입니다. “ABC”, “BCD”가 있을 때 2의 길이로 모든 조합을 구하면 “BC”는 두 번 중복되어야 합니다.실패하는 테스트를 작성합니다.test(&quot;문자열 배열이 주어졌을 때 주어진 길이만큼 조합한다&quot;, () =&amp;gt; { expect(combinateStrings([&quot;XYZ&quot;, &quot;XWY&quot;, &quot;WXA&quot;], 2)).toEqual([ &quot;AW&quot;, &quot;AX&quot;, &quot;WX&quot;, &quot;WX&quot;, &quot;WY&quot;, &quot;XY&quot;, &quot;XY&quot;, &quot;XZ&quot;, &quot;YZ&quot;, ]);});테스트 코드를 통과하도록 코드를 작성합니다.function combinateStrings(array, n) { return array .map((s) =&amp;gt; combinateString(s, n)) .reduce((acc, cur) =&amp;gt; [...acc, ...cur], []) .sort();}+ 문자열조합(&quot;ABC&quot;, 2) = [&quot;AB&quot;, &quot;AC&quot;, &quot;BC&quot;]+ 문자열 배열 조합+ 배열에서 요소의 빈도 수를 계산해서 객체로 만들기+ 배열에서 최빈값을 가지는 요소 구하기 (최빈값이 같을 경우 모두 포함)+ 주어진 배열에서 특정 길이만큼 조합하기솔루션 함수이제 모든 할일이 끝났으니 최종 솔루션 함수의 테스트 코드를 작성합니다.test(&quot;메뉴 리뉴얼&quot;, () =&amp;gt; { expect( solution([&quot;ABCFG&quot;, &quot;AC&quot;, &quot;CDE&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;ACDEH&quot;], [2, 3, 4]) ).toEqual([&quot;AC&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;CDE&quot;]); expect(solution([&quot;XYZ&quot;, &quot;XWY&quot;, &quot;WXA&quot;], [2, 3, 4])).toEqual([&quot;WX&quot;, &quot;XY&quot;]);});테스트 코드를 통과하도록 코드를 작성합니다.function solution(orders, course) { return course .map((n) =&amp;gt; combinateStrings(orders, n)) .flatMap(mostFrequent) .sort();}📚 함께 보기" }, { "title": "VanillaJS로 선언형 컴포넌트 만들기", "url": "/posts/declarative-component/", "categories": "TIL", "tags": "자바스크립트", "date": "2022-03-09 00:00:00 +0900", "snippet": "💁 설명바닐라JS를 이용하여 선언형 컴포넌트를 만듭니다.공통 준비사항index.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;title&amp;gt;선언형 컴포넌트&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&quot;main.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;위와 같이 html 파일이 주어졌을 때 각 미션마다 주어진 요구사항을 만족하는 main.js 파일을 만듭니다.토글 버튼 만들기요구사항- [ ] 화면에 버튼을 3개 만들고, 버튼을 클릭하면 취소선이 그어지도록 하세요.단계별 추상화명령형 프로그래밍 방식const $button1 = document.createElement(&quot;button&quot;);$button1.textContent = &quot;버튼1&quot;;const $button2 = document.createElement(&quot;button&quot;);$button2.textContent = &quot;버튼2&quot;;const $button3 = document.createElement(&quot;button&quot;);$button3.textContent = &quot;버튼3&quot;;const $app = document.querySelector(&quot;#app&quot;);$app.appendChild($button1);$app.appendChild($button2);$app.appendChild($button3);document.querySelectorAll(&quot;button&quot;).forEach(($button) =&amp;gt; { $button.addEventListener(&quot;click&quot;, (e) =&amp;gt; { const { target } = e; if (target.style.textDecoration === &quot;line-through&quot;) { target.style.textDecoration = &quot;none&quot;; } else { target.style.textDecoration = &quot;line-through&quot;; } });});위 코드에서 if문으로 시작하는 target.style.textDecoration 코드 청크(chunk)는 target 데이터를 처리하는 규칙을 코드로 적은 것입니다. 요약하면, “취소선이 그어져 있으면 취소선을 없애고, 취소선이 없으면 취소선을 긋는 토글 기능”입니다. 데이터를 처리하는 하나의 규칙을 하나의 함수로 분리하면, 여러 줄의 코드가 하나의 이름으로 추상화되어 코드의 가독성이 올라갑니다.정리: 동일한 데이터를 처리하는 여러 줄의 코드 가독성 올리기 동일한 데이터를 처리하는 규칙을 담고 있는 여러 줄의 코드를 하나의 함수로 분리합니다. 규칙을 몇 단어로 요약하여 함수의 이름으로 붙입니다.그러면 여러 줄의 코드가 하나의 이름(함수 이름)으로 추상화되어 코드의 가독성이 올라갑니다.토글 기능을 함수로 추상화const $button1 = document.createElement(&quot;button&quot;);$button1.textContent = &quot;버튼1&quot;;const $button2 = document.createElement(&quot;button&quot;);$button2.textContent = &quot;버튼2&quot;;const $button3 = document.createElement(&quot;button&quot;);$button3.textContent = &quot;버튼3&quot;;const $app = document.querySelector(&quot;#app&quot;);$app.appendChild($button1);$app.appendChild($button2);$app.appendChild($button3);const toggleLineThrough = (button) =&amp;gt; { if (button.style.textDecoration === &quot;line-through&quot;) { button.style.textDecoration = &quot;none&quot;; } else { button.style.textDecoration = &quot;line-through&quot;; }};document.querySelectorAll(&quot;button&quot;).forEach(($button) =&amp;gt; { $button.addEventListener(&quot;click&quot;, (e) =&amp;gt; { const { target } = e; toggleLineThrough(target); });});이제 선언형 프로그래밍 방식으로 바꿔보겠습니다. 선언형 프로그래밍의 특징은 무언가를 구현한다고 할 때, 그것을 구현하는 순서나 방법 같은 “어떻게”를 작성하는 게 아니라 구현하고자 하는 바가 “무엇”인지 작성하는 것입니다.HTML 요소를 예로 들어보겠습니다. Github 주소인 www.github.com으로 이동하는 링크를 구현한다고 하면 아래와 같이 작성하면 됩니다.&amp;lt;a href=&quot;www.github.com&quot;&amp;gt;Github으로 이동&amp;lt;/a&amp;gt;요소 a가 “어떻게” 동작하는지 우리는 전혀 모릅니다. href 속성에 URL을 넣으면 그게 안에서 어떻게 처리되는지도 모릅니다. 클릭 이벤트를 어떻게 처리하는지도 보이지 않습니다. 다만 링크 요소를 구현할 때 필요한 핵심 정보인 a, href=&quot;www.github.com&quot;, Github으로 이동을 명시적으로 전달할 뿐입니다. 동작에 대한 세부적인 구현은 숨겨져 있습니다.정리: 선언형으로 컴포넌트를 작성하는 방법컴포넌트의 핵심 데이터는 밖에서 전달하고 세부 구현은 안으로 숨깁니다.토글 버튼을 사용하는 입장에서 핵심 정보는 무엇일까요? “(1) 토글 버튼을 어디에 추가할 것인지”와 “(2) 버튼 텍스트”만 밖에서 전달하도록 하고 나머지는 컴포넌트 내부에 뭉쳐보겠습니다.선언형 프로그래밍 방식function ToggleButton({ $target, text }) { const $button = document.createElement(&quot;button&quot;); let isInit = false; this.toggle = () =&amp;gt; { if ($button.style.textDecoration === &quot;line-through&quot;) { $button.style.textDecoration = &quot;none&quot;; } else { $button.style.textDecoration = &quot;line-through&quot;; } }; this.render = () =&amp;gt; { $button.textContent = text; if (!isInit) { $target.appendChild($button); $button.addEventListener(&quot;click&quot;, () =&amp;gt; { this.toggle(); }); isInit = true; } }; this.render();}const $app = document.querySelector(&quot;#app&quot;);new ToggleButton({ $target: $app, text: &quot;버튼1&quot;,});new ToggleButton({ $target: $app, text: &quot;버튼2&quot;,});new ToggleButton({ $target: $app, text: &quot;버튼3&quot;,});토글 버튼에 필요한 내용들이 ToggleButton에 모두 응집되었습니다. new ToggleButton()으로 토글 버튼을 생성하는 코드를 보면 토글 버튼을 만드는 방법이 매우 간단해졌다는 것을 알 수 있습니다. 핵심 데이터는 밖에서 전달하고 나머지 세부구현은 컴포넌트 내부로 숨긴 덕분에 코드를 재사용하는 것도 간편해졌고, 작성된 코드를 읽는 것도 매우 쉬워졌습니다. 이밖에 토글 버튼 코드를 유지보수하고 기능을 확장하는 관점에서 선언형 방식은 어떤 이점이 있을까요?명령형 방식과 선언형 방식에 동일한 기능을 새롭게 추가한다고 가정해볼게요. 위 선언형 방식에서는 ToggleButton 컴포넌트 안에 새로운 기능을 추가하면 됩니다. 하지만 명령형 방식은 토글 버튼을 담당하는 코드의 범위나 영역이 불분명하고, 코드의 순서가 명령의 순서이기 때문에 명령의 순서를 잘 알아야 하고, 기능을 추가하다가 자칫 명령의 순서가 잘못 꼬일 위험이 있습니다. 코드의 길이가 조금만 길어져도 명령형 코드는 쉽게 한 눈에 잘 들어오지 않기 때문입니다. 반면에 선언형 토글 버튼은 렌더링되는 시점 등 찾고자 하는 코드의 의도가 어디에 있는지 한 눈에 알 수 있습니다.좀 더 구체적으로 버튼의 토글 횟수를 세는 기능을 추가한다고 가정해보겠습니다.명령형 방식const $button1 = document.createElement(&quot;button&quot;);$button1.textContent = &quot;버튼1&quot;;$button1.className = &quot;button1&quot;; // 어떤 버튼인지 알기 위해 클래스를 추가한다let button1ToggleCount = 0; // 버튼1에 대한 토글 카운트 변수를 추가한다const $button2 = document.createElement(&quot;button&quot;);$button2.textContent = &quot;버튼2&quot;;$button2.className = &quot;button2&quot;;let button2ToggleCount = 0;const $button3 = document.createElement(&quot;button&quot;);$button3.textContent = &quot;버튼3&quot;;$button3.className = &quot;button3&quot;;let button3ToggleCount = 0;const $app = document.querySelector(&quot;#app&quot;);$app.appendChild($button1);$app.appendChild($button2);$app.appendChild($button3);const toggleLineThrough = (button) =&amp;gt; { if (button.style.textDecoration === &quot;line-through&quot;) { button.style.textDecoration = &quot;none&quot;; if (button.className === &quot;button1&quot;) { // 버튼1이라면 button1ToggleCount++; button.textContent = `버튼1 (${button1ToggleCount})`; } if (button.className === &quot;button2&quot;) { // 버튼2이라면 button2ToggleCount++; button.textContent = `버튼2 (${button2ToggleCount})`; } if (button.className === &quot;button3&quot;) { // 버튼3이라면 button3ToggleCount++; button.textContent = `버튼3 (${button3ToggleCount})`; } } else { button.style.textDecoration = &quot;line-through&quot;; }};document.querySelectorAll(&quot;button&quot;).forEach(($button) =&amp;gt; { $button.addEventListener(&quot;click&quot;, (e) =&amp;gt; { const { target } = e; toggleLineThrough(target); });});위와 같이 명령형으로 작성해도 정상적으로 동작하지만, 버튼의 개수가 더 많아진다거나 또 다른 새로운 기능을 추가해야 하는 상황이 오면 버그가 만들어질 확률이 큽니다. 코드가 길어지고 복잡해질수록 원하는 코드의 로직을 찾기가 더 어려워지기 때문입니다. 선언형 방식으로 동일한 기능 추가를 구현해보겠습니다.정리: 명령형으로 작성한 토글 버튼 코드가 기능을 추가할수록 복잡해지는 이유취소선을 긋는 토글 기능은 함수로 분리되어 재사용이 가능해졌지만, 만들어진 토글 버튼을 식별하는 이름(ex. button1, button2, button3)은 재사용이 불가능하고 일일이 관리해야 하기 때문입니다. 결과적으로 명령형으로 작성된 토글 버튼 코드는, 토글 버튼에 대한 식별자가 필요한 기능을 하나씩 추가 구현할 때마다 로직 내부의 코드도 복잡도가 증가할 수밖에 없습니다.선언형 방식function ToggleButton({ $target, text }) { const $button = document.createElement(&quot;button&quot;); let isInit = false; let toggleCount = 0; this.toggle = () =&amp;gt; { if ($button.style.textDecoration === &quot;line-through&quot;) { $button.style.textDecoration = &quot;none&quot;; toggleCount++; $button.textContent = `${text} (${toggleCount})`; } else { $button.style.textDecoration = &quot;line-through&quot;; } }; this.render = () =&amp;gt; { $button.textContent = text; if (!isInit) { $target.appendChild($button); isInit = true; } }; $button.addEventListener(&quot;click&quot;, () =&amp;gt; { this.toggle(); }); this.render();}const $app = document.querySelector(&quot;#app&quot;);new ToggleButton({ $target: $app, text: &quot;버튼1&quot;,});new ToggleButton({ $target: $app, text: &quot;버튼2&quot;,});new ToggleButton({ $target: $app, text: &quot;버튼3&quot;,});반면에 선언적으로 작성한 토글 버튼 컴포넌트는 버튼에 대한 식별자가 컴포넌트 내부에 있어서 식별자가 필요한 기능을 새롭게 추가하더라도 간단하게 처리할 수 있습니다.기능 추가하기 1요구사항- [ ] 3번 클릭하면 alert 창을 띄우세요.구현function ToggleButton({ $target, text }) { const $button = document.createElement(&quot;button&quot;); let isInit = false; let clickCount = 0; this.toggle = () =&amp;gt; { if ($button.style.textDecoration === &quot;line-through&quot;) { $button.style.textDecoration = &quot;none&quot;; } else { $button.style.textDecoration = &quot;line-through&quot;; } }; this.render = () =&amp;gt; { if (!isInit) { $button.textContent = text; $target.appendChild($button); isInit = true; } }; $button.addEventListener(&quot;click&quot;, () =&amp;gt; { clickCount++; this.toggle(); if (clickCount % 3 === 0) { alert(&quot;3번째 클릭!&quot;); } }); this.render();}const $app = document.querySelector(&quot;#app&quot;);new ToggleButton({ $target: $app, text: &quot;버튼1&quot;,});new ToggleButton({ $target: $app, text: &quot;버튼2&quot;,});new ToggleButton({ $target: $app, text: &quot;버튼3&quot;,});나머지 연산 로직을 컴포넌트 내부에 추가하여 간단하게 기능을 추가할 수 있습니다.기능 추가하기 2요구사항- [ ] 첫번째 버튼은 2번 클릭하면 alert 창을 띄우고 두번째 버튼은 3번 클릭하면 alert 버튼을 띄우세요.동일한 컴포넌트에 서로 다른 동작 구현하기토글 버튼의 취소선 토글 기능은 동일하지만 그 외에 서로 다른 동작을 하게 만들려면 어떻게 해야 할까요? 가장 간단한 방법 중 하나는 외부에서 행동을 주입하는 것입니다.function ToggleButton({ $target, text, onClick }) { const $button = document.createElement(&quot;button&quot;); let isInit = false; let clickCount = 0; this.toggle = () =&amp;gt; { if ($button.style.textDecoration === &quot;line-through&quot;) { $button.style.textDecoration = &quot;none&quot;; } else { $button.style.textDecoration = &quot;line-through&quot;; } }; this.render = () =&amp;gt; { if (!isInit) { $button.textContent = text; $target.appendChild($button); isInit = true; } }; $button.addEventListener(&quot;click&quot;, () =&amp;gt; { clickCount++; this.toggle(); onClick &amp;amp;&amp;amp; onClick(clickCount); }); this.render();}const $app = document.querySelector(&quot;#app&quot;);new ToggleButton({ $target: $app, text: &quot;버튼1&quot;, onClick: (clickCount) =&amp;gt; { if (clickCount % 2 === 0) { alert(&quot;2번째 클릭!&quot;); } },});new ToggleButton({ $target: $app, text: &quot;버튼2&quot;, onClick: (clickCount) =&amp;gt; { if (clickCount % 3 === 0) { alert(&quot;3번째 클릭!&quot;); } },});new ToggleButton({ $target: $app, text: &quot;버튼3&quot;,});정리: 재사용이 가능한 컴포넌트에 별개의 행동을 추가하는 방법컴포넌트 외부에서 컴포넌트 내부로 행동을 주입하면 됩니다. 이렇게 되면 코드를 읽는 관점에서도 이득이 생깁니다. 왜냐하면 컴포넌트를 사용할 때 하고자 하는 행동을 코드로 드러내게 되어, 해당 컴포넌트가 어떤 별개의 행동을 할 지 한 눈에 알 수 있기 때문입니다. 여전히 &quot;핵심 정보는 밖에서 전달하고, 세부 구현은 안으로 숨긴다&quot;는 규칙을 지켜서 코드의 로직을 쉽게 파악할 수 있게 됩니다.기능 추가하기 3요구사항- [ ] 기존 토글 버튼에서 버튼을 클릭하기 전에 볼드(bold) 처리하고 클릭하면 bold 처리를 취소하도록 만드세요.기존 코드에서 기능을 추가할 경우기존 코드를 유지하면서 볼드 표시를 토글하는 기능을 추가하려면 아래와 같이, 초기 스타일에 볼드 처리를 하고 toggle 함수 안에도 if문을 추가하여 볼드 처리 로직을 추가해야 합니다.function ToggleButton({ $target, text, onClick }) { const $button = document.createElement(&quot;button&quot;); $button.style.fontWeight = &quot;700&quot;; // added let isInit = false; let clickCount = 0; this.toggle = () =&amp;gt; { if ($button.style.textDecoration === &quot;line-through&quot;) { $button.style.textDecoration = &quot;none&quot;; } else { $button.style.textDecoration = &quot;line-through&quot;; } // added if ($button.style.fontWeight === &quot;700&quot;) { $button.style.fontWeight = &quot;&quot;; // 참고로 빈 문자열을 넣으면 해당 스타일의 기본값이 반영됩니다. } else { $button.style.fontWeight = &quot;700&quot;; } }; this.render = () =&amp;gt; { if (!isInit) { $button.textContent = text; $target.appendChild($button); isInit = true; } }; $button.addEventListener(&quot;click&quot;, () =&amp;gt; { clickCount++; this.toggle(); onClick &amp;amp;&amp;amp; onClick(clickCount); }); this.render();}그런데 토글 상태에 따라 UI를 업데이트하게 만들면 더 편하지 않을까요?가령 다음과 같이 말입니다:$button.style.textDecoration = toggled ? &quot;line-through&quot; : &quot;none&quot;;$button.style.fontWeight = toggled ? &quot;&quot; : &quot;700&quot;;잘 생각해보면 토글 버튼 컴포넌트가 렌더링하는 흐름을 다음과 같이 정리할 수 있습니다: 사용자가 클릭하면 토글 상태가 변경된다. 즉, 이벤트 발생 =&amp;gt; 컴포넌트의 상태 변경 토글 상태가 변경되면 규칙에 따라 스타일이 변경되어야 한다. 즉, 상태 변경 =&amp;gt; UI 변경우리가 해야 할 일은 크게 다음과 같습니다: 이벤트 발생에 따라 상태 변경하기 변경된 상태에 따라 UI 렌더링하기상태에 따라 렌더링하도록 만들기function ToggleButton({ $target, text, onClick }) { const $button = document.createElement(&quot;button&quot;); let isInit = false; // 상태 초기화 this.state = { clickCount: 0, toggled: false, }; // 03 상태가 변경되면 리렌더링한다 this.setState = (nextState) =&amp;gt; { this.state = nextState; // 상태 변경 this.render(); // 리렌더 }; // 04 렌더 함수는 현재 상태를 기준으로 렌더링을 한다 this.render = () =&amp;gt; { $button.textContent = `${text} (${this.state.clickCount})`; $button.style.textDecoration = this.state.toggled ? &quot;line-through&quot; : &quot;none&quot;; $button.style.fontWeight = this.state.toggled ? &quot;&quot; : &quot;700&quot;; if (!isInit) { $target.appendChild($button); isInit = true; } }; // 01 이벤트가 발생하면 $button.addEventListener(&quot;click&quot;, () =&amp;gt; { // 02 상태를 변경하고 this.setState({ clickCount: this.state.clickCount + 1, toggled: !this.state.toggled, }); // 개별 행동도 마찬가지로 현재 상태를 기준으로 행동을 한다 onClick &amp;amp;&amp;amp; onClick(this.state.clickCount); }); this.render();}달라진 점: 이벤트가 발생하면 UI를 바로 변경하는게 아니라 상태를 변경하게 되었습니다. 상태가 변경되면 자동으로 리렌더링하게 되었습니다. UI를 변경하는 토글 함수 코드가 렌더 함수 내부로 이동했습니다.즉, 컴포넌트가 “상태가 변경되면 자동으로 리렌더링”하는 일련의 흐름을 가지게 되었습니다. 코드가 일련의 흐름을 가지면 코드의 유지보수와 확장이 쉬워집니다. 원하는 로직이 어디에 있는지 더 쉽게 알 수 있기 때문입니다. 가령, 이전처럼 DOM을 여기저기서 수정할 필요가 없어졌습니다. DOM 수정은 UI와 관련된 코드이므로 렌더 함수 안에서 찾고 변경하면 됩니다.graph LR subgraph 컴포넌트의 흐름 A[&quot;이벤트 발생&quot;] --&amp;gt; B B[&quot;상태 변경&quot;] --&amp;gt; C[&quot;리렌더링&quot;] end이제 새로운 기능을 추가하고 싶다면 우리가 할 일은 다음으로 구분됩니다: 이벤트 발생에 따라 상태를 어떻게 변경하면 될지 코드를 작성합니다. 상태에 따라 UI를 어떻게 변경하면 될지 코드를 작성합니다.기능 추가하기 4요구사항- [ ] 5초 뒤에 자동으로 토글되는 버튼을 만드세요.구현기존 토글 버튼을 확장해서 구현할 수 있습니다.function TimerButton({ $target, text, timer = 3000 }) { const button = new ToggleButton({ $target, text, onClick: () =&amp;gt; { setTimeout(() =&amp;gt; { button.setState({ ...button.state, toggled: !button.state.toggled, }); }, timer); }, });}function ToggleButton({ $target, text, onClick }) { const $button = document.createElement(&quot;button&quot;); let isInit = false; this.state = { clickCount: 0, toggled: false, }; this.setState = (nextState) =&amp;gt; { this.state = nextState; this.render(); }; this.render = () =&amp;gt; { $button.textContent = `${text} (${this.state.clickCount})`; $button.style.textDecoration = this.state.toggled ? &quot;line-through&quot; : &quot;none&quot;; if (!isInit) { $target.appendChild($button); isInit = true; } }; $button.addEventListener(&quot;click&quot;, () =&amp;gt; { this.setState({ clickCount: this.state.clickCount + 1, toggled: !this.state.toggled, }); onClick &amp;amp;&amp;amp; onClick(this.state.clickCount); }); this.render();}const $app = document.querySelector(&quot;#app&quot;);new ToggleButton({ $target: $app, text: &quot;버튼1&quot;, onClick: (clickCount) =&amp;gt; { if (clickCount % 2 === 0) { alert(&quot;2번째 클릭!&quot;); } },});new ToggleButton({ $target: $app, text: &quot;버튼2&quot;, onClick: (clickCount) =&amp;gt; { if (clickCount % 3 === 0) { alert(&quot;3번째 클릭!&quot;); } },});new ToggleButton({ $target: $app, text: &quot;버튼3&quot;,});new TimerButton({ $target: $app, text: &quot;3초 타이머&quot;,});new TimerButton({ $target: $app, text: &quot;10초 타이머&quot;, timer: 10 * 1000,});기능 추가하기 5요구사항- [ ] 인자로 type과 timer 값을 입력하면 자동으로 토글 버튼이나 타이머 버튼을 추가하는 ButtonGroup 컴포넌트를 만드세요.구현function ButtonGroup({ $target, buttons }) { const $group = document.createElement(&quot;div&quot;); let isInit = false; this.render = () =&amp;gt; { if (!isInit) { buttons.forEach(({ type, ...props }) =&amp;gt; { if (type === &quot;toggle&quot;) { new ToggleButton({ $target: $group, ...props }); } else if (type === &quot;timer&quot;) { new TimerButton({ $target: $group, ...props }); } }); $target.appendChild($group); isInit = true; } }; this.render();}function TimerButton({ $target, text, timer = 3000 }) { const button = new ToggleButton({ $target, text, onClick: () =&amp;gt; { setTimeout(() =&amp;gt; { button.setState({ ...button.state, toggled: !button.state.toggled, }); }, timer); }, });}function ToggleButton({ $target, text, onClick }) { const $button = document.createElement(&quot;button&quot;); let isInit = false; this.state = { clickCount: 0, toggled: false, }; this.setState = (nextState) =&amp;gt; { this.state = nextState; this.render(); }; this.render = () =&amp;gt; { $button.textContent = `${text} (${this.state.clickCount})`; $button.style.textDecoration = this.state.toggled ? &quot;line-through&quot; : &quot;none&quot;; if (!isInit) { $target.appendChild($button); isInit = true; } }; $button.addEventListener(&quot;click&quot;, () =&amp;gt; { this.setState({ clickCount: this.state.clickCount + 1, toggled: !this.state.toggled, }); onClick &amp;amp;&amp;amp; onClick(this.state.clickCount); }); this.render();}const $app = document.querySelector(&quot;#app&quot;);new ButtonGroup({ $target: $app, buttons: [ { type: &quot;toggle&quot;, text: &quot;토글 버튼&quot;, }, { type: &quot;timer&quot;, text: &quot;타이머 버튼&quot;, timer: 1000, }, ],});📚 함께 보기" }, { "title": "리액트 useEffect 최적화하기 (feat. 타이머 컴포넌트)", "url": "/posts/react-useEffect-optimization/", "categories": "TIL", "tags": "리액트, 오래된클로저, useeffect", "date": "2022-02-22 00:00:00 +0900", "snippet": "💁 설명useEffect를 사용할 때 자주 변하는 값을 의존성 배열에 넣으면 변하는 빈도만큼 이펙트가 실행되어 성능적으로 낭비가 될 수 있습니다. useEffect의 의존성 배열에 있는 종속성이 너무 자주 변경될 때 최적화할 수 있는 패턴을 타이머 컴포넌트를 예시로 들어서 정리합니다.TR;DR이펙트에서 상태를 업데이트할 때 클로저를 사용하여 상태를 참조하면 오래된 클로저(stale closure)가 발생할 수 있어서 의존성 배열에 상태를 추가해야만 한다. 결과적으로 상태가 바뀔 때마다 계속 이펙트가 실행된다. 하지만 상태를 업데이트할 때 함수로 처리하면 의존성 배열에 상태를 추가하지 않아도 최신 렌더링에 속한 상태를 이용할 수 있다. 그리고 의존성 배열에 상태가 빠지므로 상태가 바뀌더라도 이펙트를 실행하지 않게 되어 최적화를 할 수 있다.useEffect 최적화graph LR A[&quot;useEffect(effect)&quot;] -- &quot;after every render&quot; --&amp;gt; B[&quot;Run effect&quot;]리액트의 useEffect 훅은 기본적으로 컴포넌트를 마운트할 때와 업데이트할 때마다 실행됩니다.모든 렌더링 이후에 이펙트(effect)를 적용하는 것은 때때로 성능 저하를 일으킬 수 있으므로 useEffect의 두 번째 인수에 의존성 배열을 전달하여 성능 최적화를 하는 것이 좋습니다.graph LR A[&quot;useEffect(effect, [deps])&quot;] -- &quot;when deps has changed&quot; --&amp;gt; B[&quot;Run effect&quot;]리액트는 의존성 배열에 있는 값이 변경되지 않으면 이펙트를 건너뛰므로 불필요한 이펙트 수행을 줄여서 성능 최적화를 할 수 있습니다.그런데 의존성 배열에 추가한 종속성이 너무 자주 변경되면 어떻게 될까요? 그때마다 이펙트가 실행되므로 최적화를 한 의미가 줄어듭니다.graph LR A[&quot;useEffect(effect, [deps])&quot;] -- &quot;deps changes &amp;lt;/br&amp;gt; too many times&quot; --&amp;gt; B[&quot;Run effect as many times &amp;lt;/br&amp;gt; as deps changes&quot;]타이머 컴포넌트를 예시로 들어서 useEffect의 의존성 배열에 있는 종속성이 너무 자주 변경될 때 최적화를 할 수 있는 방법을 정리합니다.타이머 컴포넌트타이머(Timer) 컴포넌트는 사용자가 버튼을 누르면 타이머 시간(timeInSeconds)을 1초씩 더해서 보여주고, 사용자가 버튼을 한 번 더 누르면 타이머 시간을 정지시킵니다.const Timer = () =&amp;gt; { // state const [timeInSeconds, setTimeInSeconds] = useState&amp;lt;number&amp;gt;(0); const [isPaused, setIsPaused] = useState&amp;lt;boolean&amp;gt;(true); // effect useEffect(() =&amp;gt; { // 타이머가 정지되어 있으면 얼리 리턴하여 이펙트를 종료합니다. if (isPaused) { return; } // 타이머 시간을 1초마다 1씩 더하는 setInterval을 실행합니다. const id = setInterval(() =&amp;gt; { setTimeInSeconds(timeInSeconds + 1); }, 1000); // effect가 재실행되면 이전에 실행된 setInterval을 취소합니다. return () =&amp;gt; clearInterval(id); }, [isPaused, timeInSeconds]); // UI return ( &amp;lt;&amp;gt; &amp;lt;p&amp;gt;타이머 시간: {timeInSeconds}초&amp;lt;/p&amp;gt; &amp;lt;button onClick={() =&amp;gt; setIsPaused((prev) =&amp;gt; !prev)}&amp;gt; {isPaused ? &#39;시작&#39; : &#39;정지&#39;} &amp;lt;/button&amp;gt; &amp;lt;/&amp;gt; );};리액트가 위 컴포넌트를 실행하는 순서는 다음과 같습니다.초기 렌더링: useState를 사용하여 타이머 정지 여부(isPaused)와 타이머 시간(timeInSeconds)을 초기화한다. 브라우저가 DOM을 모두 그리고 나서 useEffect에 등록된 이펙트를 실행한다. 타이머가 정지 여부의 초기값이 true이므로 얼리 리턴되어 이펙트가 종료된다.사용자가 시작 버튼을 누른 경우: 컴포넌트의 상태인 isPaused가 false로 변경되므로 컴포넌트가 리렌더링된다. 브라우저가 DOM을 모두 그리고 나서 useEffect에 등록된 이펙트를 실행한다. (타이머 정지 여부 값이 false이므로) 타이머 시간을 1초마다 1씩 더하는 setInterval을 실행한다. setInterval에 의해 timerInSeconds값이 1초마다 1씩 증가한다. 컴포넌트 상태인 timeInSeconds가 변경되었으므로 컴포넌트를 리렌더링한다. 브라우저가 DOM을 모두 그리고 나서, (의존성 배열의 종속성인 timeInSeconds가 변경되었으므로) 이펙트를 실행한다. 3~6을 반복한다.즉, 한 번 이펙트가 실행되면, 컴포넌트 상태가 업데이트되고, 컴포넌트 상태(timeInSeconds)가 업데이트 되었으므로 컴포넌트가 리렌더링되고, DOM을 모두 그리고 나서 (이펙트의 의존성 배열의 종속성(timeInSeconds)도 변경되었으므로) 이펙트가 다시 실행되는 순환구조입니다.graph LR A[이펙트 실행] -- &quot;이펙트 내부에서 1초마다 &amp;lt;/br&amp;gt; 컴포넌트 상태(timeInSeconds) &amp;lt;/br&amp;gt; 업데이트&quot; --&amp;gt; B B[컴포넌트 리렌더링] -- &quot;이펙트 종속성(timeInSeoncds) &amp;lt;/br&amp;gt; 변경었으므로 &amp;lt;/&amp;gt; 이펙트 실행&quot; --&amp;gt; Acodesandbox에서 콘솔에 로그를 찍어서 직접 확인해보겠습니다. 매초마다 effect가 실행된다단순화하기생각해보면, “이펙트에서 상태를 업데이트하고 이펙트 의존성에 상태를 넣는 것”은 결국 컴포넌트 상태가 바뀔 때마다 이펙트를 실행하라는 것과 같은 의미이고, 컴포넌트 상태가 바뀌면 컴포넌트가 리렌더링되므로, “컴포넌트 리렌더링과 이펙트 실행을 순환적으로 실행”하도록 만듭니다.타이머 컴포넌트에서 useEffect의 의존성 배열에 상태 timeInSeconds를 넣을 수밖에 없는 이유는 이펙트 코드가 컴포넌트 상태 timeInSeconds를 참조하고 있고, 이펙트가 실행될 때마다 최신 렌더링에 속하는 timeInSeconds를 참조해야 하기 때문입니다. 의존성 배열에 timeInSeconds를 생략할 경우 오래된 클로저(stale closure) 문제가 발생하여 이펙트는 초기 렌더링 때 참조했던 timeInSeconds 값(0)을 참조하게 되어 타이머 값이 setTimeInSeconds(0 + 1)로 인해 1로 증가한 이후로는 더 이상 증가하지 않는 버그가 발생합니다.useEffect(() =&amp;gt; { setState(state + 1); // 👀 클로저를 사용하여 state를 참조하고 있다}, [state]);위 코드처럼 이펙트에서 상태를 업데이트하는 로직을 포함시키면서 이펙트 실행을 최적화할 수 있는 방법은 무엇일까요? 리액트 공식 문서 Hooks FAQ를 보면 너무 자주 변하는 종속성에 대해 최적화를 하는 예시를 찾을 수 있습니다. 결론부터 말씀드리면, 리액트는 상태를 업데이트할 때 함수로 처리할 수 있다는 점을 이용하면 됩니다.useEffect(() =&amp;gt; { setState((prevState) =&amp;gt; newState);}, []); // ✅ 의존성 배열에서 state를 제거할 수 있다상태 업데이트를 함수로 처리하여 해결하기const Timer = () =&amp;gt; { // ...state... // effect useEffect(() =&amp;gt; { if (isPaused) { return; } const id = setInterval(() =&amp;gt; { setTimeInSeconds((prevTime) =&amp;gt; prevTime + 1); }, 1000); return () =&amp;gt; clearInterval(id); }, [isPaused]); // ...UI...};이제 이펙트는 사용자가 버튼을 눌러서 isPaused 값이 변할 때만 실행되고 상태 timeInSeconds 이 변하더라도 실행되지 않습니다.codesandbox에서 로그를 찍어서 확인해본 결과 다음과 같습니다. 타이머 버튼을 누를 때만 effect가 실행된다📚 함께 보기 React - Hooks FAQ: What can I do if my effect dependencies change too often codesandbox - 타이머 컴포넌트 최적화 이전 codesandbox - 타이머 컴포넌트 최적화 이후 오래된 클로저(stale closure)" }, { "title": "지킬 블로그에 랜덤 포스트 보기 기능 추가하기", "url": "/posts/random-post/", "categories": "TIL", "tags": "jekyll", "date": "2022-02-15 00:00:00 +0900", "snippet": "💁 설명블로그 글이 추가되면서 틈틈이 지난 글을 되돌아보고 퇴고하는 일이 잦아졌습니다. 그런데 직접 글을 특정해서 찾아가기보다는 랜덤으로 제시해주면 여러 가지 글을 골고루 볼 수 있을 것 같은 생각이 들었습니다.지킬 블로그에 랜덤 포스트 보기 기능을 추가하면서 어떻게 개발했는지 정리합니다.TL;DR모든 포스트 URL을 보여주는 동일한 도메인의 리소스를 크롤링하여 랜덤 URL로 이동하는 방식으로 기능을 구현했습니다.사이드바에 랜덤 메뉴 아이템 추가하기_tabs 디렉토리에 random.md 파일을 생성합니다.---layout: randomtitle: Randomicon: fas fa-infoorder: 5---사이드바에서 랜덤 메뉴에 대한 클릭 이벤트 핸들러 등록 ⚠️ Update 2022.3.15 _includes/sidebar.html에 다음 코드를 추가합니다:&amp;lt;!-- ...중략... --&amp;gt;&amp;lt;!-- random post --&amp;gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; const random = document.querySelector(&quot;[href*=&#39;/random&#39;]&quot;); if (random) { random.addEventListener(&quot;click&quot;, (e) =&amp;gt; { e.preventDefault(); fetch(&quot;/archives&quot;) .then((response) =&amp;gt; response.text()) .then((htmlText) =&amp;gt; { const parser = new DOMParser(); const document = parser.parseFromString(htmlText, &quot;text/html&quot;); const posts = document.querySelectorAll(&quot;#archives [href*=posts]&quot;); const links = Array.from(posts).map((post) =&amp;gt; post.href); const randomIndex = Math.floor(Math.random() * links.length); const randomLink = links[randomIndex]; window.location = randomLink; }); }); }&amp;lt;/script&amp;gt; sidebar.html 코드 전문 &amp;lt;!-- The Side Bar--&amp;gt;&amp;lt;div id=&quot;sidebar&quot; class=&quot;d-flex flex-column align-items-end&quot; lang=&quot;{{lang}}&quot;&amp;gt; &amp;lt;div class=&quot;profile-wrapper text-center&quot;&amp;gt; &amp;lt;div id=&quot;avatar&quot;&amp;gt; &amp;lt;a href=&quot;{{ &#39;/&#39; | relative_url }}&quot; alt=&quot;avatar&quot; class=&quot;mx-auto&quot;&amp;gt; {% if site.avatar != &#39;&#39; and site.avatar %} {% capture avatar_url %} {%- if site.avatar contains &#39;://&#39; -%} {{ site.avatar }} {%- elsif site.img_cdn != &#39;&#39; and site.img_cdn -%} {{ site.avatar | prepend: site.img_cdn }} {%- else -%} {{ site.avatar | relative_url }} {%- endif -%} {% endcapture %} &amp;lt;img src=&quot;{{ avatar_url }}&quot; alt=&quot;avatar&quot; onerror=&quot;this.style.display=&#39;none&#39;&quot;&amp;gt; {% endif %} &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;site-title mt-3&quot;&amp;gt; &amp;lt;a href=&quot;{{ &#39;/&#39; | relative_url }}&quot;&amp;gt;{{ site.title }}&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;site-subtitle font-italic&quot;&amp;gt;{{ site.tagline }}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;!-- .profile-wrapper --&amp;gt; &amp;lt;ul class=&quot;w-100&quot;&amp;gt; &amp;lt;!-- home --&amp;gt; &amp;lt;li class=&quot;nav-item{% if page.layout == &#39;home&#39; %}{{ &quot; active&quot; }}{% endif %}&quot;&amp;gt; &amp;lt;a href=&quot;{{ &#39;/&#39; | relative_url }}&quot; class=&quot;nav-link&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt;{{ site.data.locales[lang].tabs.home | upcase }}&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;!-- the real tabs --&amp;gt; {% for tab in site.tabs %} &amp;lt;li class=&quot;nav-item{% if tab.url == page.url %}{{ &quot; active&quot; }}{% endif %}&quot;&amp;gt; &amp;lt;a href=&quot;{{ tab.url | relative_url }}&quot; class=&quot;nav-link&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw {{ tab.icon }} ml-xl-3 mr-xl-3 unloaded&quot;&amp;gt;&amp;lt;/i&amp;gt; {% capture tab_name %}{{ tab.url | split: &#39;/&#39; }}{% endcapture %} &amp;lt;span&amp;gt;{{ site.data.locales[lang].tabs.[tab_name] | default: tab.title | upcase }}&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;!-- .nav-item --&amp;gt; {% endfor %} &amp;lt;/ul&amp;gt; &amp;lt;!-- ul.nav.flex-column --&amp;gt; &amp;lt;div class=&quot;sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center&quot;&amp;gt; {% for entry in site.data.contact %} {% capture url %} {%- if entry.type == &#39;github&#39; -%} https://github.com/{{ site.github.username }} {%- elsif entry.type == &#39;twitter&#39; -%} https://twitter.com/{{ site.twitter.username }} {%- elsif entry.type == &#39;email&#39; -%} {% assign email = site.social.email | split: &#39;@&#39; %} javascript:location.href = &#39;mailto:&#39; + [&#39;{{ email[0] }}&#39;,&#39;{{ email[1] }}&#39;].join(&#39;@&#39;) {%- elsif entry.type == &#39;rss&#39; -%} {{ &quot;/feed.xml&quot; | relative_url }} {%- else -%} {{ entry.url }} {%- endif -%} {% endcapture %} {% if url %} &amp;lt;a href=&quot;{{ url }}&quot; aria-label=&quot;{{ entry.type }}&quot; {% unless site.theme_mode %}class=&quot;order-{{ forloop.index | plus: 2 }}&quot;{% endunless %} {% unless entry.noblank %}target=&quot;_blank&quot; rel=&quot;noopener&quot;{% endunless %}&amp;gt; &amp;lt;i class=&quot;{{ entry.icon }}&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; {% endif %} {% endfor %} {% unless site.theme_mode %} {% if site.data.contact.size &amp;gt; 0 %} &amp;lt;span class=&quot;icon-border order-2&quot;&amp;gt;&amp;lt;/span&amp;gt; {% endif %} &amp;lt;span id=&quot;mode-toggle-wrapper&quot; class=&quot;order-1&quot;&amp;gt; {% include mode-toggle.html %} &amp;lt;/span&amp;gt; {% endunless %} &amp;lt;/div&amp;gt; &amp;lt;!-- .sidebar-bottom --&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;!-- #sidebar --&amp;gt;&amp;lt;!-- random post --&amp;gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; const random = document.querySelector(&quot;[href*=&#39;/random&#39;]&quot;); if (random) { random.addEventListener(&#39;click&#39;, (e) =&amp;gt; { e.preventDefault(); fetch(&quot;/archives&quot;) .then((response) =&amp;gt; response.text()) .then((htmlText) =&amp;gt; { const parser = new DOMParser(); const document = parser.parseFromString(htmlText, &quot;text/html&quot;); const posts = document.querySelectorAll(&quot;#archives [href*=posts]&quot;); const links = Array.from(posts).map((post) =&amp;gt; post.href); const randomIndex = Math.floor(Math.random() * links.length); const randomLink = links[randomIndex]; window.location = randomLink; }) }) }&amp;lt;/script&amp;gt; 레이아웃 추가하기 ⚠️ DEPREATED 위 내용이 추가됨에 따라 이 방식은 더 이상 사용되고 있지 않습니다.random.md 파일에 레이아웃을 적용하기 위해 _layouts 디렉토리에 /random.html 파일을 추가합니다.---layout: page# The random post layout---&amp;lt;div&amp;gt;...loading&amp;lt;/div&amp;gt; 랜덤 포스팅을 불러오기 전에 로딩 메시지 ...loading을 보여줍니다.현재 블로그에서 사용하고 있는 Chirpy Starter는 /arhicves URL로 이동하면 모든 포스트 목록을 보여줍니다. /archives 리소스를 사용하여 모든 포스트 목록의 URL을 파싱한 후 랜덤으로 고른 포스트 URL로 이동하는 코드를 즉시 실행 함수(IIFE)로 작성합니다.---layout: page# The random post layout---&amp;lt;div&amp;gt;...loading&amp;lt;/div&amp;gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; // here (function main() { // 모든 포스트 URL 목록이 나오는 /archives 리소스를 파싱합니다. fetch(&quot;/archives&quot;) .then((response) =&amp;gt; response.text()) .then((htmlText) =&amp;gt; { // html text를 DOM 파서를 이용하여 파싱합니다. const parser = new DOMParser(); const document = parser.parseFromString(htmlText, &quot;text/html&quot;); // href에 /posts/* 를 포함하고 있는 모든 요소를 찾습니다. const posts = document.querySelectorAll(&quot;#archives [href*=posts]&quot;); const links = Array.from(posts).map((post) =&amp;gt; post.href); // 링크 배열에서 랜덤 인덱스를 선택한 후 해당 포스트 URL로 이동합니다. const randomIndex = Math.floor(Math.random() * links.length); const randomLink = links[randomIndex]; window.location = randomLink; }); })();&amp;lt;/script&amp;gt; fetch 메서드를 실행할 때 동일한 오리진의 리소스를 가져오므로 SOP(Same Origin Policy)를 준수합니다. 따라서 CORS(Cross Origin Resource Sharing)를 따로 허용해줄 필요가 없습니다.📚 함께 읽기 stackoverflow - returning HTML with fetch()" }, { "title": "화폐 예제 실습으로 TDD의 리듬 느껴보기 - 2. 타락한 객체", "url": "/posts/tdd-currency-2/", "categories": "TIL, TDD", "tags": "tdd, tdd-by-example", "date": "2022-02-12 00:00:00 +0900", "snippet": "💁 프롤로그 시리즈 “화폐 예제 실습으로 TDD의 리듬 느껴보기“에서 사용되는 공통 프롤로그입니다.graph LR A[?] --&amp;gt; B[Clean code that works]어떻게 하면 작동하는 깔끔한 코드(clean code that works)를 얻을 수 있을까요? 켄트 벡(Kent Beck)은 자동화된 테스트로 개발을 이끌어 가는 테스트 주도 개발(TDD, Test Driven Development)을 제안합니다. 과연 TDD를 하면 작동하는 깔끔한 코드를 얻을 수 있는지, 어떤 이유로 그러한지 궁금하네요. 책 테스트 주도 개발(Test Driven Development: By Example)을 읽고 실습한 내용을 정리합니다. 실습 코드 회고 TDD 시작하기 TDD는 두 가지 규칙을 따릅니다: 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다. 중복을 제거한다. 위 규칙에 의해 TDD로 코드를 짜는 순서는 다음과 같이 결정됩니다. 레드(RED) - 실패하는 작은 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다. 그린(GREEN) - 빨리 테스트가 통과하게끔 만든다. 이를 위해 어떤 죄악을 저질러도 좋다. 리팩토링(REFACTOR) - 일단 테스트를 통과하게만 하는 와중에 생겨난 모든 중복을 제거한다. 죄악이란 기존 코드 복사해서 붙이기(copy and paste), 테스트만 간신히 통과할 수 있게끔 함수가 무조건 특정 상수를 반환하도록 구현하기 등을 의미한다. graph LR A[&quot;🔴 RED&quot;] --&amp;gt;B B[&quot;🟢 GREEN&quot;] --&amp;gt;C C[&quot;🔵 REFACTOR&quot;] --&amp;gt;A 리팩토링(Refactoring)이란 코드의 외적 행위는 그대로 유지하면서 내부 구조를 변경하는 작업을 뜻한다. 화폐 예제의 목표 화폐 예제를 실습하면서 가져야 할 목표는 TDD의 리듬을 느껴보는 것입니다. 내 목표는 여러분이 테스트 주도 개발(TDD)의 리듬을 보도록 하는 것이다. 그 리듬은 다음과 같이 요약할 수 있다. 재빨리 테스트를 하나 추가한다. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다. 코드를 조금 바꾼다. 모든 테스트를 실행하고 전부 성공하는지 확인한다. 리팩토링을 통해 중복을 제거한다. 아마 당신은 다음과 같은 것에 대해 놀랄 것이다. 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지 새 테스트를 돌아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지 얼마나 자주 테스트를 실행하는지 얼마나 수없이 작은 단계를 통해 리팩토링이 되어가는지 1 이 예제를 통해 여러분은 코딩하기 전에 먼저 테스트를 만드는 법과 설계를 유기적으로 키워나가는(grow) 방법을 배우게 될 것이다. 2 화폐 예제 요구사항 AS-IS에서 TO-BE로 변경하는 것이 화폐 예제의 요구사항입니다. AS-IS 다음과 같은 보고서가 있다. 종목 주 가격 합계 IBM 1000 25 2500 GE 400 100 40000     합계 65000 TO-BE 다중 통화를 지원하는 보고서를 만들어야 한다. 환율을 명시해야 한다. 종목 주 가격 합계 IBM 1000 25USD 2500USD GE 400 100CHF 40000CHF     합계 65000USD 기준 변환 환율 CHF USD 1.5 할일 목록 읽는 법 $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기- Dollar 부작용(side effect)? Money 반올림? 일반: 작업해야 할 항목 빨강: 현재 작업을 시작한 항목 초록: 작업을 끝낸 항목 🎬 2장 타락한 객체 3일반적인 TDD 주기는 어떻게 될까 테스트를 작성한다. 마음 속에 있는 오퍼레이션이 코드에 어떤 식으로 나타나길 원하는지 생각해보라. 이야기를 써내려가는 것이다. 원하는 인터페이스를 개발하라. 올바른 답을 얻기 위해 필요한 이야기의 모든 요소를 포함시켜라. 실행 가능하게 만든다. 다른 무엇보다도 중요한 것은 빨리 초록 막대를 보는 것이다. 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력하라. 만약 깔끔하고 단순한 해법이 있지만 구현하는 데 몇 분 정도 걸릴 것 같으면 일단 적어 놓은 뒤에 원래 문제(초록 막대를 보는 것)로 돌아오자. (…) 빨리 초록 막대를 보는 것은 모든 죄를 사해준다. 하지만 아주 잠시 동안만이다. 올바르게 만든다. 이제 시스템이 작동하므로 직전에 저질렀던 죄악을 수습하자. 중복을 제거하고 초록 막대로 되돌리자. flowchart LR subgraph A[&quot;🟢 GREEN&quot;] direction LR a1[&quot;깔끔한 해결법이 있지만 &amp;lt;/br&amp;gt; 구현에 시간이 걸릴 것 같으면 &amp;lt;/br&amp;gt; 일단 적어두고 &amp;lt;br/&amp;gt; 테스트를 빠르게 통과시킨다&quot;] end subgraph B[&quot;🔵 REFACTOR&quot;] direction LR b1[&quot;저질렀던 죄악을 수습하고 &amp;lt;/br&amp;gt; 중복을 제거한다&quot;] end subgraph C[&quot;🔴 RED&quot;] direction LR c1[&quot;테스트를 작성하면서 &amp;lt;/br&amp;gt; 인터페이스를 개발한다&quot;] end A --&amp;gt; B B --&amp;gt; C C --&amp;gt; A깔끔한 해결법이 떠올랐는데 구현이 오래 걸릴 것 같으면 구현을 완성하지 않고 죄악(깔끔하지 않고 예기치 못한 문제가 있을 수도 있지만 일단 테스트를 통과시키는 행동)을 저지르고 나서 죄악을 수습하라고 합니다. 왜 이렇게 할까요? 나누어서 정복하자(divide and conquer). 일단 ‘작동하는 깔끔한 코드’를 얻어야 한다는 전체 문제 중에서 ‘작동하는’에 해당하는 부분을 먼저 해결하라. 그러고 나서 ‘깔끔한 코드’ 부분을 해결하는 것이다.죄악 수습하기 $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기- Dollar 부작용(side effect)? Money 반올림?Dollar에 부작용이 있습니다. Dollar에 연산을 수행하면 해당 Dollar의 값이 바뀐다는 점입니다. 5달러 객체는 어떤 연산을 수행하더라도 5달러로 계속해서 남아 있길 바랍니다. 즉 원하는 달러 객체의 오퍼레이션은 다음과 같습니다.test(&quot;곱하기&quot;, () =&amp;gt; { const five: Dollar = new Dollar(5); five.times(2); expect(product.amount).toBe(10); five.times(3); expect(product.amount).toBe(15);}); 하지만 이 테스트를 통과할 명쾌한 방법이 떠오르지 않는다. times()를 처음 호출한 이후에 five는 더 이상 5가 아니다. 그렇다면 times()에서 새로운 객체를 반환하게 만들면 어떨까? 그렇게 하면 원래의 5달러를 가지고 온종일 곱하기를 수행해도 원래 5달러의 값은 변하지 않을 것이다. 이렇게 하려면 Dollar의 인터페이스를 수정해야 하고, 그러기 위해서는 테스트도 수정해야 한다. 문제될 건 없다. 어떤 구현이 올바른가에 대한 우리 추측이 완벽하지 못한 것과 마찬가지로 올바른 인터페이스에 대한 추측 역시 절대 완벽하지 못하다.테스트를 작성하면 자연스럽게 인터페이스를 개발하게 되는데 지금 생각하는 인터페이스가 완벽하지 못해도 괜찮습니다. 올바른 인터페이스에 대한 추측은 절대 완벽하지 못하기 때문입니다.대신 우리가 할 일은 부작용의 느낌을 테스트 코드로 변환하는 것입니다.test(&quot;곱하기&quot;, () =&amp;gt; { const five: Dollar = new Dollar(5); let product: Dollar; product = five.times(2); expect(product.amount).toBe(10); product = five.times(3); expect(product.amount).toBe(15);});새 테스트는 컴파일조차 되지 않을 테니 Dollar.times()를 수정합니다.class Dollar { times(multiplier: number) { this.amount *= multiplier; return null; }}테스트를 통과하기 위해 올바른 금액을 갖는 새 Dollar를 반환합니다.class Dollar { times(multiplier: number) { return new Dollar(this.amount * multiplier); }}테스트가 통과되었습니다! $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기+ Dollar 부작용(side effect)? Money 반올림?저자가 실무에서 TDD를 사용할 때 쓰는 방법 다음은 최대한 빨리 초록색을 보기 위해 취할 수 있는 내가 아는 세 전략 중 두 가지다. 가짜로 구현하기: 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다. 명백한 구현 사용하기: 실제 구현을 입력한다. 나는 보통 실무에서 TDD를 사용할 때 두 방법을 번갈아가며 사용한다. 모든 일이 자연스럽게 잘 진행되고 내가 뭘 입력해야 할지 알 때는 명백한 구현을 계속 더해 나간다. 예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방법을 사용하면서 올바른 코드로 리팩토링한다. 그러다 다시 자신감을 되찾으면 명백한 구현 사용하기 모드로 돌아온다.간단합니다. 테스트 코드를 통과시키는 방법이 떠오르면 실제 구현 코드를 짜고 아니면 상수를 반환했다가 단계적으로 상수를 변수로 바꾸어 간다고 합니다. ‘나같은 대부분의 평범한 프로그래머’라고 말한 저자의 말4을 조금은 수긍하게 됩니다.정리 지금까지 배운 것을 검토해보자. 우리는 설계상의 결함(Dollar 부작용)을 그 결함으로 인해 실패하는 테스트로 변환했다. 스텁 구현으로 빠르게 컴파일을 통과하도록 만들었다. 올바르다고 생각하는 코드를 입력하여 테스트를 통과했다. 느낌(부작용에 대한 혐오감)을 테스트(하나의 Dolalr 객체에 곱하기를 두 번 수행하는 것)로 변환하는 것은 TDD의 일반적 주제다. 이런 작업을 오래 할수록 미적 판단을 테스트로 담아내는 것에 점점 익숙해지게 된다.작성한 테스트 코드에서 부작용에 대한 느낌이 오면 그 느낌을 테스트로 변환한다고 합니다. 그러니까 이미 통과하는 코드를 작성해서 “작동하는” 코드를 만들고, 부작용에 대한 느낌을 다시 테스트 코드로 변환하여 “깔끔한” 코드를 얻어내는 거죠.flowchart LR subgraph A[&quot;🟢 GREEN&quot;] direction LR a1[&quot;테스트를 빠르게 통과시켜서 &amp;lt;/br&amp;gt; 동작하는 코드를 만든다&quot;] end subgraph B[&quot;🔵 REFACTOR&quot;] direction LR b1[&quot;저질렀던 죄악을 수습해서 &amp;lt;/br&amp;gt; 깔끔한 코드를 만든다&quot;] end subgraph C[&quot;🔴 RED&quot;] direction LR c1[&quot;부작용에 대한 혐오감을 &amp;lt;/br&amp;gt; 테스트로 변환한다&quot;] end A --&amp;gt; B B --&amp;gt; C C --&amp;gt; A그게 저자가 작동하는 깔끔한 코드(clean code that works)를 분할 정복(divide and conquer)으로 얻어내는 방법 같습니다. 테스트를 빠르게 통과(GREEN)시켜서 동작(works)하는 코드부터 만들고, 죄악을 수습(REFACTOR)해서 깔끔(clean)하게 만드는 것.그리고 프롤로그에 있는 “설계를 유기적으로 키워나가는(grow) 방법”과 관련한 언급을 하고 마무리됩니다. 이걸 할 수 있을 때, 설계 논의는 훨씬 더 흥미로워진다. 우선 시스템이 이런 식으로 동작해야 하는지 저런 식으로 동작해야 하는지 논의할 수 있다. 일단 올바른 행위에 대해 결정을 내린 후에, 그 행위를 얻어낼 수 있는 최상의 방법에 대해 이야기할 수 있다.📚 함께 읽기 테스트 주도 개발 실습 코드 회고🔖 주석 테스트 주도 개발. 1부. 38쪽. &amp;#8617; 테스트 주도 개발. 들어가는 글. 27쪽. &amp;#8617; 테스트 주도 개발. 2장. 53쪽. &amp;#8617; 테스트 주도 개발. 2장. 54쪽. &amp;#8617; " }, { "title": "회고 - 화폐 예제 실습으로 TDD의 리듬 느껴보기", "url": "/posts/retro-tdd-currency-1/", "categories": "Retrospective", "tags": "tdd, tdd-by-example", "date": "2022-02-11 15:00:00 +0900", "snippet": "💁 설명화폐 예제 실습으로 TDD의 리듬 느껴보기를 하면서 느낀 점을 회고합니다.📝 회고 무엇을 했고 무엇을 느꼈는지 적고 배운 점을 액션 플랜으로 연결해봅니다.1장 다중 통화를 지원하는 Money 객체“TDD 리듬이 깨지지 않도록 할일 목록을 지속적으로 관리해보자”what: 다중 통화를 지원하는 Money 객체를 만들기 위해 할일 목록과 테스트 코드를 작성하면서 테스트 코드를 통과시키는 작업을 했다.before: 이전에 TDD로 개발을 했을 때는 할일 목록은 처음에만 간단하게 주석으로 작성하고 주로 테스트 코드를 어떻게 작성해야 할지에 집중했다.after: 그런데 책을 읽고 실습하면서 인상깊었던 점이 할일 목록을 한 곳에 두고 지속적으로 업데이트한다는 점이었다. 그리고 그렇게 할일 목록을 한 곳에 두고 관리하면 지금 하고 있는 일에서 벗어나지 않게 막아주고 이런 장치가 TDD 리듬이 깨지지 않도록 도와주는데 일조한다고 느꼈다.과거에 테스트 코드를 빠르게 통과시키기 위해 작업을 하다 보면 지금 작성한 코드가 예기치 못한 사이드 이펙트를 커버하지 못하는 것을 깨닫고 코드를 수정하거나 추가하는 등 작업의 범위가 예상보다 커져버려서 TDD의 리듬이 깨지는 경우도 종종 있었다. 그런데 책에서 제안하는 해결책은 매우 간단했다. 문제점이 눈에 보이면 할일 목록에 적어두고 그냥 넘어가고, 기존에 하던 작업을 계속 진행한다.이제부터는 TDD를 할 때 할일 목록을 app.todo.md 같은 이름의 파일로 분리해서 작업하는 동안 지속적으로 관리해봐야겠다. 그러면 기존에 TDD 리듬이 깨지던 문제를 해결할 수 있을 것 같다.2장 타락한 객체“완벽한 인터페이스가 떠오를 때까지 테스트 코드를 미루는 게 아니다”“작동하는 깔끔한 코드를 얻어내는 방법 중 하나가 TDD 프로세스에 담겨 있다”what: 타락한 객체의 죄악을 수습하기 위해 부작용에 대한 혐오감을 테스트로 변환하는 작업을 했다.before: 테스트 코드를 통과시키는 구현 코드를 작성하는 와중에 예상하지 못했던 이런 저런 부작용이 느껴질 때가 있다. ‘아, 테스트 코드를 잘못 짰구나’. 그러면 하던 걸 멈추고 테스트 코드를 수정하게 된다.after: 그런데 (동작 자체가 잘못된 게 아니라면) 일단 동작하는 코드를 만들고 나서 부작용의 느낌을 테스트 코드로 변환하면 된다는 걸 배웠다. 그리고 그게 저자가 작동하는 깔끔한 코드(clean code that works)를 분할 정복(divide and conquer)으로 얻어내는 방법이었다. 테스트를 빠르게 통과(GREEN)시켜서 동작하는 코드부터 만들고, 죄악을 수습(REFACTOR)해서 깔끔하게 만드는 것.TDD를 할 때 테스트 코드를 통과시키려고 구현 코드를 짜다가 부작용이 느껴졌는데 동작 자체가 잘못된 게 아니라면 테스트 코드를 바로 수정하는 게 아니라 일단 그린을 얻어내서 작동하는 코드를 만들고, 그 다음에 리팩터링으로 깔끔한 코드를 얻어내자.3장 모두를 위한 평등“디자인 패턴을 사용하면 또 다른 오퍼레이션을 구현해야 할 것이다”“설계를 어떻게 해야 할지, 프로그램이 어떻게 변화할지 감이 잡히지 않을 때는 삼각측량을 사용하자”what: 값 객체 패턴을 사용했고, 값 동치성 오퍼레이션에 대한 테스트 코드를 추가하고 통과시켰다. 이때 삼각측량을 사용하여 테스트 코드를 통과시켰다.before: 값 객체 패턴이 무엇인지 몰랐다.after: 값 객체 패턴을 언제, 왜 사용하는 것인지 배웠다. 특정 도메인에서 값을 나타내려고 하는데 primitive type이 적절하지 않을 경우 값 객체 패턴을 사용하면 유용하다. 테스트 코드를 구현할 때 해답이 보이면 바로 그 방법대로 구현하면 된다. 하지만 만약 설계를 어떻게 해야 할지, 리팩토링을 어떻게 해야 할지 감이 안 잡힌다면 삼각측량을 사용하여 일반적인 해를 요구하는 테스트 케이스를 추가해보자.📚 See also 화폐 예제 실습으로 TDD의 리듬 느껴보기 (feat. TypeScript)" }, { "title": "화폐 예제 실습으로 TDD의 리듬 느껴보기 - 1. 다중 통화를 지원하는 Money 객체", "url": "/posts/tdd-currency-1/", "categories": "TIL, TDD", "tags": "tdd, tdd-by-example", "date": "2022-02-11 00:00:00 +0900", "snippet": "💁 프롤로그 시리즈 “화폐 예제 실습으로 TDD의 리듬 느껴보기“에서 사용되는 공통 프롤로그입니다.graph LR A[?] --&amp;gt; B[Clean code that works]어떻게 하면 작동하는 깔끔한 코드(clean code that works)를 얻을 수 있을까요? 켄트 벡(Kent Beck)은 자동화된 테스트로 개발을 이끌어 가는 테스트 주도 개발(TDD, Test Driven Development)을 제안합니다. 과연 TDD를 하면 작동하는 깔끔한 코드를 얻을 수 있는지, 어떤 이유로 그러한지 궁금하네요. 책 테스트 주도 개발(Test Driven Development: By Example)을 읽고 실습한 내용을 정리합니다. 실습 코드 회고TDD 시작하기TDD는 두 가지 규칙을 따릅니다: 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다. 중복을 제거한다.위 규칙에 의해 TDD로 코드를 짜는 순서는 다음과 같이 결정됩니다. 레드(RED) - 실패하는 작은 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다. 그린(GREEN) - 빨리 테스트가 통과하게끔 만든다. 이를 위해 어떤 죄악을 저질러도 좋다. 리팩토링(REFACTOR) - 일단 테스트를 통과하게만 하는 와중에 생겨난 모든 중복을 제거한다. 죄악이란 기존 코드 복사해서 붙이기(copy and paste), 테스트만 간신히 통과할 수 있게끔 함수가 무조건 특정 상수를 반환하도록 구현하기 등을 의미한다.graph LR A[&quot;🔴 RED&quot;] --&amp;gt;B B[&quot;🟢 GREEN&quot;] --&amp;gt;C C[&quot;🔵 REFACTOR&quot;] --&amp;gt;A 리팩토링(Refactoring)이란 코드의 외적 행위는 그대로 유지하면서 내부 구조를 변경하는 작업을 뜻한다.화폐 예제의 목표화폐 예제를 실습하면서 가져야 할 목표는 TDD의 리듬을 느껴보는 것입니다. 내 목표는 여러분이 테스트 주도 개발(TDD)의 리듬을 보도록 하는 것이다. 그 리듬은 다음과 같이 요약할 수 있다. 재빨리 테스트를 하나 추가한다. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다. 코드를 조금 바꾼다. 모든 테스트를 실행하고 전부 성공하는지 확인한다. 리팩토링을 통해 중복을 제거한다. 아마 당신은 다음과 같은 것에 대해 놀랄 것이다. 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지 새 테스트를 돌아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지 얼마나 자주 테스트를 실행하는지 얼마나 수없이 작은 단계를 통해 리팩토링이 되어가는지 1 이 예제를 통해 여러분은 코딩하기 전에 먼저 테스트를 만드는 법과 설계를 유기적으로 키워나가는(grow) 방법을 배우게 될 것이다. 2화폐 예제 요구사항AS-IS에서 TO-BE로 변경하는 것이 화폐 예제의 요구사항입니다. AS-IS 다음과 같은 보고서가 있다. 종목 주 가격 합계 IBM 1000 25 2500 GE 400 100 40000     합계 65000 TO-BE 다중 통화를 지원하는 보고서를 만들어야 한다. 환율을 명시해야 한다. 종목 주 가격 합계 IBM 1000 25USD 2500USD GE 400 100CHF 40000CHF     합계 65000USD 기준 변환 환율 CHF USD 1.5 할일 목록 읽는 법 $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기- Dollar 부작용(side effect)? Money 반올림? 일반: 작업해야 할 항목 빨강: 현재 작업을 시작한 항목 초록: 작업을 끝낸 항목🎬 1장 다중 통화를 지원하는 Money 객체 3어떤 테스트들이 있어야 코드가 완성됐다는 걸 확신할 수 있을까새로운 보고서를 생성하기 위해 어떤 기능이 필요할까요? 이 질문을 “어떤 테스트가 있어야 코드가 완성됐다는 걸 확신할 수 있을까?”로 바꿔서 생각합니다.graph LR A[어떤 기능이 필요할까?] --&amp;gt; B[어떤 테스트가 있어야 할까?] 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다. 어떤 금액을 어떤 개수에 곱한 금액을 결과로 얻을 수 있어야 한다.그리고 할일 목록을 작성합니다. 앞으로 어떤 일을 해야 하는지 알려주고, 지금 하는 일에 집중할 수 있도록 도와주며, 언제 일이 다 끝나는지 알려줄 수 있게끔 할일 목록을 작성해보자. 앞으로 할일 목록에 있는 한 항목에 대한 작업을 시작하면 이런 식으로 굵은 글씨체로 나타낼 것이다. 작업을 끝낸 항목에는 이런 식으로 줄을 긋도록 하자. 또다른 테스트가 생각나면 할일 목록에 새로운 항목을 추가할 것이다. $5 + 10CHF = $10(환율이 2:1일 경우) $5 * 2 = $10작고 간단한 테스트부터 작성합니다. 할일 목록을 보니 첫 번째 테스트는 좀 복잡해 보인다. 작은 것부터 시작하든지, 아니면 아예 손대지 않는 게 좋다. 이번엔 다음 항목인 곱하기를 보자. 대단히 어렵진 않겠지? 이걸 먼저 하는 게 좋겠다. $5 + 10CHF = $10(환율이 2:1일 경우)- $5 * 2 = $10작성의 편의를 위해 작업을 시작한 항목을 빨간색으로 나타내고, 작업을 끝낸 항목은 녹색으로 나타내겠습니다.test(&quot;곱하기&quot;, () =&amp;gt; { const five: Dollar = new Dollar(5); five.times(2); expect(five.amount).toBe(10);});재빨리 테스트를 추가했는데 문제점이 있습니다. 문제점을 할일 목록에 적어 놓습니다. 그래, 나도 안다. 공용 필드(public field)에다가, 예기치 못한 부작용이 있을 수도 있고, 금액을 계산하는 데 정수형을 사용한다. 하지만 작은 단계로 시작하는 것뿐이다. 이런 문제들을 적어 놓고 계속 진행하자. 지금 우리에겐 실패하는 테스트가 주어진 상태고 최대한 빨리 초록 막대를 보고 싶을 뿐이다. $5 + 10CHF = $10(환율이 2:1일 경우)- $5 * 2 = $10 amount를 private으로 만들기 Dollar 부작용(side effect)? Money 반올림?방금 우리가 작성한 테스트는 아직 컴파일조차 되지 않습니다. Dollar 클래스 없음 생성자 없음 times(number) 메서드 없음 amount 필드 없음한 번에 하나씩 정복합니다. 컴파일만 되게 할 거니까 “최소한”의 코드만 작성합니다.// Dollar 클래스 정의class Dollar { amount: number; // amount 필드 추가 constructor(amount) {} // 생성자 정의 times(multiplier: number) {} // 스텁 구현}test(&quot;곱하기&quot;, () =&amp;gt; { const five: Dollar = new Dollar(5); five.times(2); expect(five.amount).toBe(10);});스텁 구현스텁 구현은 메서드의 서명부와 (반환값이 있을 경우) 반환 명령만 적는 식으로 해서, 이 메서드를 호출하는 코드가 컴파일 될 수 있도록 껍데기만 만들어두는 것을 뜻한다.이제 테스트가 실패하는 모습(RED)을 볼 수 있게 됐습니다!Expected: 10Received: 5 이것도 일종의 진척이다. 이제 실패에 대한 구체적인 척도를 갖게 된 것이다. 막연히 실패했다는 사실만 아는 것보다 나아진 것이다. 우리 문제는 ‘다중 통화 구현’에서 ‘이 테스트를 통과시킨 후 나머지 테스트들도 통과시키기’로 변형된 것이다. 훨씬 간단하다. 범위도 훨씬 적어서 걱정이 줄었다. 이 테스트를 통과시키는 건 쉽다.테스트를 통과(GREEN)시키기 위한 “최소” 작업을 합니다.class Dollar { amount: number = 10; // here constructor(amount) {} times(multiplier: number) {}}test(&quot;곱하기&quot;, () =&amp;gt; { const five: Dollar = new Dollar(5); five.times(2); expect(five.amount).toBe(10);});테스트가 통과(GREEN)되었습니다! 계속 진행하기 전에 일반화해야 한다. 주기는 다음과 같다. 잊지 말 것. 작은 테스트를 하나 추가한다. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다. 조금 수정한다. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다. 중복을 제거하기 위해 리팩토링을 한다. 지금까지 주기의 1번부터 4번까지 진행했습니다. 이제 중복을 제거할 차례다. 그런데 어디가 중복이란 말인가? 보통 여러분은 중복을 찾기 위해 코드를 비교할 것이다. 하지만 이번 경우엔 중복이 테스트에 있는 데이터와 코드에 있는 데이터 사이에 존재한다. 못 찾겠는가? 코드를 다음과 같이 썼다면 어땠을까?class Dollar { amount: number = 5 * 2;} 이제 5와 2가 두 곳에 존재한다. 따라서 우린 무자비하게 이 중복을 제거해야 한다. 규칙이 그러니까.5와 2를 한 번에 제거할 수 있는 방법은 없다. 하지만 객체의 초기화 단계에 있는 설정 코드를 times() 메서드 안으로 옮겨보면 어떨까?class Dollar { amount: number; constructor(amount) {} times(multiplier: number) { this.amount = 5 * 2; // here }}테스트는 여전히 통과(GREEN)합니다. 이 단계가 너무 작게 느껴지는가? 하지만 기억하기 바란다. TDD의 핵심은 이런 작은 단계를 밟아야 한다는 것이 아니라, 이런 작은 단계를 밟을 능력을 갖추어야 한다는 것이다. (…) 여러분이 직접 예제를 선택하여 작은 단계로 구현하는 연습을 해보기 바란다. 만약 정말 작은 단계로 작업하는 방법을 배우면, 저절로 적절한 크기의 단계로 작업할 수 있게 될 것이다.5를 어디서 얻을 수 있을까요? 이건 생성자에서 넘어오는 값이니 다음과 같이 amount 변수에 저장하면,class Dollar { constructor(amount) { this.amount = amount; }}times()에서 사용할 수 있습니다.class Dollar { times(multiplier: number) { this.amount = this.amount * 2; }}인자 multiplier의 값이 2이므로, 상수를 이 인자로 대체합니다.class Dollar { times(multiplier: number) { this.amount = this.amount * multiplier; }}중복을 제거하기 위해 *= 연산자를 써줍니다.class Dollar { times(multiplier: number) { this.amount *= multiplier; }}이제 할일 목록에서 첫 번째 테스트에 완료 표시를 할 수 있게 되었습니다. $5 + 10CHF = $10(환율이 2:1일 경우)+ $5 * 2 = $10 amount를 private으로 만들기 Dollar 부작용(side effect)? Money 반올림?정리 지금까지 한 작업을 검토해보자. 우리는 다음 작업들을 해냈다. 우리가 알고 있는 작업해야 할 테스트 목록을 만들었다. 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다. 스텁 구현을 통해 테스트를 컴파일했다. 끔찍한 죄악을 범하여 테스트를 통과시켰다. 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다. 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다. 오퍼레이션오퍼레이션은 보통 메서드(method)와 비슷한 의미로 쓰이며 객체가 수행할 수 있는 연산을 의미한다. 엄격하게는 오퍼레이션에 대한 특정한 하나의 구현을 메서드라고 부른다. 언어가 다형성(polymorphism)을 지원할 경우 한 오퍼레이션은 여러 메서드를 가질 수 있다.“처음부터 완벽한 코드를 짜자”라고 말하면 동의하는 개발자는 아마 찾아보기 힘들 겁니다. 이번 실습을 하면서, 완벽한 코드를 짜지 못하는 평범한 개발자가 어떻게 하면 TDD라는 개발 방법을 사용해서 차근차근 문제를 해결해나가는지 그 과정을 아주 구체적으로 엿볼 수 있었습니다.가령, 테스트 코드를 실행하기 위해서 구현 코드를 모두 짜는 게 아니라 최소한의 작업인 컴파일 코드만 짜는 점, 작업을 하다가 새로운 작업 이슈가 생기면 작업을 새로운 작업까지 포함해서 작업을 하는 게 아니라 (할일 목록에 추가만 해두고) 기존 작업 크기를 유지하는 점이 그렇습니다.📚 함께 읽기 테스트 주도 개발 실습 코드 회고🔖 주석 테스트 주도 개발. 1부. 38쪽. &amp;#8617; 테스트 주도 개발. 들어가는 글. 27쪽. &amp;#8617; 테스트 주도 개발. 1장. 41쪽. &amp;#8617; " }, { "title": "리액트 앱을 위한 Jest 환경 세팅하기 (feat. Babel, TypeScript, React Testing Library)", "url": "/posts/jest-for-react-typescript/", "categories": "TIL", "tags": "jest, 환경설정, 리액트", "date": "2022-02-10 00:00:00 +0900", "snippet": "💁 설명타입스크립트로 리액트 앱을 개발할 때 테스트 코드를 작성할 수 있도록 Jest 환경을 세팅하는 방법을 정리합니다.참고: babel-jest를 사용하는 이유타입스크립트가 호환되는 Jest 환경을 구축할 때 ts-jest 를 사용할 수도 있고 babe-jest를 사용할 수도 있다. 그런데 JS로 구성되었다가 TS로 마이그레이션 하는 프로젝트에서 ts-jest를 사용할 경우 JS로 작성된 파일의 테스트가 제대로 동작하지 않는 문제가 발견되어 JS와 TS 파일 모두 잘 동작하는 babel-jest를 사용합니다.⚙️ 세팅프로젝트 초기화npm init -yJest, babel-jest, TypeScript 설치npm i -D jest babel-jest @babel/core @babel/preset-env @babel/preset-typescript typescript @types/jestDescribe-Context-It 플러그인 설치describe와 it 사이에 context 키워드를 사용하면, Given-When-Then과 같이 BDD 스타일로 테스트 코드를 작성할 수 있다.npm i -D jest-plugin-context @types/jest-plugin-contextReact Testing Library 설치npm i -D @testing-library/react @testing-library/user-event @testing-library/dom @testing-library/jest-dom설정 파일 생성jest --init 위 명령어를 실행하는 대신 아래 jest.config.js 파일을 그대로 복사해서 사용해도 된다.📜 설정 파일babel.config.jsmodule.exports = { presets: [ [&quot;@babel/preset-env&quot;, { targets: { node: &quot;current&quot; } }], &quot;@babel/preset-typescript&quot;, ],};jest.config.jsconst { jestPathAlias } = require(&#39;./pathAlias&#39;);module.exports = { testEnvironment: &#39;jsdom&#39;, setupFilesAfterEnv: [ &#39;@testing-library/jest-dom/extend-expect&#39;, &#39;jest-plugin-context/setup&#39;, ], testPathIgnorePatterns: [&#39;&amp;lt;rootDir&amp;gt;/node_modules/&#39;, &#39;&amp;lt;rootDir&amp;gt;/dist/&#39;], moduleNameMapper: jestPathAlias,};경로 별칭을 사용할 경우 아래와 같이 개별 파일로 분리하여 관리할 수 있다: webpack의 alias나 tsconfig의 alias 모두 아래와 같이 한 파일에서 관리하면 편하다.pathAlias.jsconst path = require(&#39;path&#39;);const resolvePath = (relativePath) =&amp;gt; path.resolve(__dirname, relativePath);module.exports = { jestPathAlias: { &#39;^@components/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/components/$1&#39;, &#39;^@hooks/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/hooks/$1&#39;, &#39;^@pages/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/pages/$1&#39;, &#39;^@contexts/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/contexts/$1&#39;, &#39;^@apis/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/apis/$1&#39;, &#39;^@assets/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/assets/$1&#39;, &#39;^@utils/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/utils/$1&#39;, &#39;^@constants/(.*)$&#39;: &#39;&amp;lt;rootDir&amp;gt;/src/constants/$1&#39;, },};package.json{ &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;, &quot;test:watch&quot;: &quot;jest --watch&quot; }}tsconfig.json{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;jsx&quot;: &quot;react-jsx&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;allowJs&quot;: true, &quot;checkJs&quot;: false, &quot;outDir&quot;: &quot;dist&quot;, &quot;esModuleInterop&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;strict&quot;: true, &quot;skipLibCheck&quot;: true, }, &quot;include&quot;: [&quot;src&quot;], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;dist&quot;, &quot;fixtures&quot;, &quot;src/**/*.test.tsx&quot;, &quot;src/**/*.test.ts&quot; ]}.eslintrc.jsmodule.exports = { env: { browser: true, es2021: true, jest: true, }, globals: { context: &#39;readonly&#39;, }, // ...}📚 See also Jest - Using Babel React Testing Library - intro React Testing Library - user-event Github - bbc/simorgh - jest.config.js" }, { "title": "Jest 환경 세팅하기 (feat. TypeScript, ESModule)", "url": "/posts/jest-typescript/", "categories": "TIL", "tags": "jest, 환경설정", "date": "2022-02-09 00:00:00 +0900", "snippet": "💁 설명ESModule 방식과 타입스크립트로 테스트 코드를 작성할 수 있는 Jest 환경을 세팅하는 방법을 정리합니다.타입스크립트로만 작성된 프로젝트일 경우 ts-jest 방식으로 설정하는 것이 빠르고, JS와 TS가 모두 호환되는 환경이 필요하다면 babel-jest를 이용한 방식을 추천합니다.참고로 저는 JS로 알고리즘 문제를 풀 때 babel-jest로 구성한 테스트 환경을 사용하고 있습니다.ESModuleES6에 도입된 모듈 시스템을 말하며 import, export를 사용합니다.⚙️ 세팅프로젝트 초기화npm init -y방법 1: babel-jestJest, babel-jest, TypeScript 설치npm i -D jest babel-jest @babel/core @babel/preset-env @babel/preset-typescript typescript @types/jestDescribe-Context-It 플러그인 설치describe와 it 사이에 context 키워드를 사용하면, Given-When-Then과 같이 BDD 스타일로 테스트 코드를 작성할 수 있다.npm i -D jest-plugin-context @types/jest-plugin-context📜 설정 파일babel.config.jsmodule.exports = { presets: [ [&quot;@babel/preset-env&quot;, { targets: { node: &quot;current&quot; } }], &quot;@babel/preset-typescript&quot;, ],};jest.config.jsmodule.exports = { clearMocks: true, testEnvironment: &quot;jsdom&quot;, setupFilesAfterEnv: [&quot;jest-plugin-context/setup&quot;], testPathIgnorePatterns: [&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;],};tsconfig.json{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es6&quot;, &quot;jsx&quot;: &quot;react-jsx&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;allowJs&quot;: true, &quot;checkJs&quot;: false, &quot;outDir&quot;: &quot;dist&quot;, &quot;esModuleInterop&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;strict&quot;: true, &quot;skipLibCheck&quot;: true, }, &quot;exclude&quot;: [ &quot;node_modules&quot;, ]}package.json{ &quot;scripts&quot;: { &quot;test&quot;: &quot;jest --verbose&quot;, &quot;test:changed&quot;: &quot;jest --onlyChanged --verbose &quot;, &quot;test:watch&quot;: &quot;jest --watch --verbose&quot;, &quot;test:changed:watch&quot;: &quot;jest --onlyChanged --watch --verbose &quot;, &quot;test:cw&quot;: &quot;npm run test:changed:watch&quot; }}방법 2: ts-jestJest, TypeScript, ts-jest 설치npm i -D jest typescript ts-jest @types/jest설정 파일 생성npx ts-jest config:init📜 설정 파일jest.config.js/** @type {import(&#39;ts-jest/dist/types&#39;).InitialOptionsTsJest} */module.exports = { preset: &quot;ts-jest&quot;, testEnvironment: &quot;jsdom&quot;, // import 키워드를 사용하는 ESModule을 사용하기 위해 jsdom으로 설정한다.};package.json{ &quot;scripts&quot;: { &quot;test&quot;: &quot;jest --verbose&quot;, &quot;test:changed&quot;: &quot;jest --onlyChanged --verbose &quot;, &quot;test:watch&quot;: &quot;jest --watch --verbose&quot;, &quot;test:changed:watch&quot;: &quot;jest --onlyChanged --watch --verbose &quot;, &quot;test:cw&quot;: &quot;npm run test:changed:watch&quot; }}📚 See also Jest - Using TypeScript via ts-jest Github - kulshekhar/ts-jest Jest - Configuring Jest: testEnvironment" }, { "title": "ESLint 설정 뜯어보기 (feat. React, TypeScript)", "url": "/posts/eslint/", "categories": "TIL", "tags": "eslint, 리액트", "date": "2022-01-26 00:00:00 +0900", "snippet": "목표리액트와 타입스크립트를 쓰는 프로젝트에서 자주 사용하는 ESLint 설정을 정리합니다. TL;DR 플러그인에 정의된 프리셋 규칙을 즉시 적용하고 싶다면: extends 플러그인에 정의된 규칙을 개별적으로 적용하고 싶다면: plugins로 불러오고 rules에 추가한다 module.exports = { // ...생략... plugins: [&quot;@typescript-eslint&quot;, &quot;prettier&quot;, &quot;jest&quot;, &quot;unicorn&quot;], extends: [ &quot;airbnb&quot;, &quot;prettier&quot;, &quot;prettier/react&quot;, &quot;plugin:prettier/recommended&quot;, &quot;plugin:jest/recommended&quot;, &quot;plugin:unicorn/recommended&quot;, ], rules: { &quot;no-console&quot;: &quot;warn&quot;, &quot;no-unused-vars&quot;: &quot;off&quot;, &quot;@typescript-eslint/no-unused-vars&quot;: [ &quot;error&quot;, { vars: &quot;all&quot;, args: &quot;after-used&quot;, ignoreRestSiblings: false }, ], &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;warn&quot;, },}; 용어 정리용어를 이해하면 ESLint 설정이 어떤 구조로 동작하는지 대략적으로 알 수 있습니다. 앞으로 글에서 말하는 린트는 ESLint를 의미하고 린트 설정 객체는 .eslintrc.js에서 내보내는 자바스크립트 객체를 의미합니다.ESLint 패키지: 용어 뜻 예시 eslint-plugin-* 커스텀 린트 규칙을 정의한 패키지 eslint-plugin-react eslint-config-* 린트 규칙뿐만 아니라 다른 ESLint 설정까지 정의한 패키지 (eslint-config-*를 포함하기도 한다) eslint-config-airbnb 린트 설정 객체 프로퍼티: 용어 뜻 자주 사용하는 값 비고 root 린트를 적용할 프로젝트의 루트가 현재 린트 설정 파일과 동일한 레벨에 있다 따라서 부모 디렉토리는 린팅 대상에 포함하지 않는다 true 또는 생략   env 프로젝트가 실행될 환경을 정의한다 각 환경에 맞는 전역 변수를 사전에 제공한다 { browser: true, es2021: true, node: true, jest: true } es* 값을 사용하면 파서 옵션의 ecmaVersion도 자동으로 설정된다 parser ESLint가 사용할 파서를 정의한다 타입스크립트의 경우 `@typescript-eslint/parser`를 사용한다     parserOptions 프로젝트에서 사용할 자바스크립트 언어 옵션을 정의한다 { &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: { &quot;jsx&quot;: true } }   parserOptions.project (`@typescript-eslint`에서 제공하는) 타입 정보를 필요로 하는 린트 규칙을 적용하려면 설정해야 한다 &quot;./tsconfig.json&quot; .js 확장자 파일을 읽을 때 에러가 발생할 수 있다 따라서 이 경우에는 타입스크립트 규칙은 타입스크립트 파일에만 적용하도록 오버라이드 할 수 있다 plugins ESLint 설정에 사용할 플러그인을 불러온다 규칙을 불러올 뿐 자동으로 **적용되지는 않는다** [&quot;@typescript-eslint&quot;]   extends 상속 받아서 **바로 적용**할 다른 ESLint 설정 파일을 정의한다 `recommended` 같은 키워드를 사용하면 패키지에 정의된 프리셋 규칙이 일괄 적용된다 예제 코드 나중에 정의한 값이 더 높은 우선순위를 갖는다 예제로 살펴보는 ESLint 설정 파일여러 공식문서에서 제공하는 .eslintrc.js 파일을 둘러봅니다. 주요 키워드는 plugins, extends, rules입니다.typescript-eslint typescript-eslint - Configuration설치:yarn add --dev eslint typescript @typescript-eslint/{eslint-plugin,parser}린트 설정 파일 작성:module.exports = { root: true, parser: &quot;@typescript-eslint/parser&quot;, plugins: [&quot;@typescript-eslint&quot;], extends: [&quot;eslint:recommended&quot;, &quot;plugin:@typescript-eslint/recommended&quot;],};정리:위 내용을 토대로 ESLint 플러그인을 적용하는 과정을 정리해보면 다음과 같습니다.graph TB A[&quot; (@typescript-eslint가 정의한) &amp;lt;/br&amp;gt; ESLint rules 플러그인 설치&quot;] -- &quot;yarn add -D @typescript-eslint/eslint-plugin&quot; --&amp;gt; B B[&quot;(프로젝트 ESLint 설정으로) &amp;lt;/br&amp;gt; 플러그인 불러오기&quot;] -- &quot;.eslintrcjs.plugins = [&#39;@typescript-eslint&#39;]&quot; --&amp;gt; C C[&quot;플러그인에 정의된 recommended rules 일괄 적용&quot;] -- &quot;.eslintrcjs.extends = [&#39;plugin:@typescript-eslint/recommended&#39;&quot; --&amp;gt; D[&quot;END &amp;lt;/br&amp;gt; 직접 수정할 규칙은 .eslintrcjs.rules에 추가한다&quot;] 단, eslint-plugin-react처럼 코드 내부에서 recommended 안에 플러그인을 불러오는 코드가 있는 경우, 플러그인 불러오기 과정 없이 extends만 작성해도 린트 규칙을 적용할 수 있다.React Typescript Cheatsheet React Typescript Cheatsheet - Lintingmodule.exports = { env: { es6: true, browser: true, jest: true, }, parser: &quot;@typescript-eslint/parser&quot;, parserOptions: { sourceType: &quot;module&quot;, ecmaFeatures: { jsx: true, }, }, plugins: [&quot;@typescript-eslint&quot;, &quot;prettier&quot;, &quot;jest&quot;, &quot;unicorn&quot;], extends: [ &quot;airbnb&quot;, &quot;prettier&quot;, &quot;prettier/react&quot;, &quot;plugin:prettier/recommended&quot;, &quot;plugin:jest/recommended&quot;, &quot;plugin:unicorn/recommended&quot;, ], rules: { indent: [&quot;error&quot;, 2], &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;], quotes: [&quot;error&quot;, &quot;single&quot;], &quot;no-console&quot;: &quot;warn&quot;, &quot;no-unused-vars&quot;: &quot;off&quot;, &quot;@typescript-eslint/no-unused-vars&quot;: [ &quot;error&quot;, { vars: &quot;all&quot;, args: &quot;after-used&quot;, ignoreRestSiblings: false }, ], &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;warn&quot;, // Consider using explicit annotations for object literals and function return types even when they can be inferred. &quot;no-empty&quot;: &quot;warn&quot;, },};이제 위 린트 설정 파일을 보면, plugins: ‘네 개의 플러그인이 갖고 있는 린트 규칙 모음을 활용하겠구나’ extends: ‘여섯 가지 패키지의 규칙 모음을 위에서부터 아래로 바로 적용하고, 규칙뿐만 아니라 다른 ESLint 설정도 불러오는구나’ rules: ‘몇 가지 규칙은 직접 추가해서 변경하는구나’라고 이해할 수 있습니다.See also 공식 문서 ESLint - configuring 기타 자료 stackoverflow - 타입스크립트 린트 규칙을 적용할 때 자바스크립트 파일은 제외하고 타입스크립트 파일에만 적용하기 TSLint 에서 ESLint 로 이사하기: parserOptions.project: &quot;./tsconfig.json&quot;로 하면 JS 파일에서 에러가 발생할 수 있다 nana.log - ESLint 알고 쓰기: ESLint config와 plugin의 차이점 Webpack으로 React + TypeScript + Styled Component + Storybook 세팅하기 Typescript &amp;amp; React &amp;amp; Eslint 환경설정 2편 ESLint &amp;amp; Prettier 설정 " }, { "title": "리액트 보일러플레이트 만들기 (feat. Webpack, TypeScript, ESLint, Prettier, Storybook)", "url": "/posts/react-boilerplate/", "categories": "TIL", "tags": "리액트, 환경설정", "date": "2022-01-24 00:00:00 +0900", "snippet": "목표Webpack을 이용해서 React + Typescript + ESLint + Prettier + Storybook 세팅하는 방법을 정리합니다.완성된 코드: datalater/react-boilerplateReact 및 TypeScript 설정디렉토리 생성 후 진입md react-boilerplatecd react-boilerplate프로젝트 초기화yarn init리액트 설치yarn add react react-dom타입스크립트 설치yarn add -D typescript @types/react @types/react-domtsconfig 작성npx tsc --inittsconfig.json 파일 수정{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;jsx&quot;: &quot;react-jsx&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;esModuleInterop&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;strict&quot;: true, &quot;skipLibCheck&quot;: true }, &quot;include&quot;: [&quot;src&quot;]}관련 옵션 설명: react-jsx: 리액트 17에서 도입된 새로운 JSX 변환 import React 없이 JSX를 사용할 수 있다 Webpack 설치yarn add -D webpack webpack-cli webpack-dev-serverwebpack 플러그인 설치yarn add -D html-webpack-plugin copy-webpack-plugin webpack-bundle-analyzer mini-css-extract-pluginwebpack 로더 설치yarn add -D babel-loader ts-loader style-loader css-loader postcss-loader sass-loader sassWebpack config 작성웹팩 설정을 개발 환경 모드와 운영 환경 모드로 분리해서 작성하고, 두 환경에서 공통적으로 쓰이는 코드는 공통 설정 파일에 작성합니다. Webpack - production웹팩 설정을 병합하는 패키지 설치yarn add -D webpack-mergeCSS 후처리 패키지 설치yarn add autoprefixerwebpack.common.js:const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const CopyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;);const MiniCSSExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const isProduction = process.env.NODE_ENV === &quot;production&quot;;module.exports = { resolve: { extensions: [&quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;, &quot;.jsx&quot;], /* alias를 사용할 경우 주석을 해제하고 사용한다. */ // alias: { // &quot;@components&quot;: path.resolve(__dirname, &quot;src/components&quot;), // }, }, entry: { app: &quot;./src/index.tsx&quot;, }, output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), clean: true, }, plugins: [ new HtmlWebpackPlugin({ filename: &quot;./index.html&quot;, template: path.resolve(__dirname, &quot;./index.html&quot;), favicon: &quot;./static/logo.png&quot;, }), new CopyWebpackPlugin({ patterns: [{ from: &quot;static&quot; }], }), isProduction &amp;amp;&amp;amp; new MiniCSSExtractPlugin({ filename: &quot;[name].css&quot;, }), ].filter(Boolean), module: { rules: [ // TSX { test: /\\.tsx?$/i, exclude: /node_modules/, use: [ // JS to older JS with polyfills { loader: &quot;babel-loader&quot;, }, // TS to JS { loader: &quot;ts-loader&quot;, }, ], }, // SCSS { test: /\\.s?css$/i, use: [ isProduction ? MiniCSSExtractPlugin.loader : &quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot;, &quot;sass-loader&quot;, ], }, // ASSETS { test: /\\.(png|jpe?g|gif|mp3)$/i, type: &quot;asset/resource&quot;, }, ], },};참조: ts-loader와 babel-loader를 함께 쓰는 이유 ts-loader와 babel-loader를 함께 쓰는 예제 코드를 언급한 문서 Microsoft/TypeScript samples - ts-loader와 babel-loader를 함께 쓰는 예제 코드postcss.config.js:const autoprefixer = require(&quot;autoprefixer&quot;);module.exports = { plugins: [autoprefixer],};webpack.dev.js:const { merge } = require(&quot;webpack-merge&quot;);const common = require(&quot;./webpack.common.js&quot;);module.exports = merge(common, { mode: &quot;development&quot;, devtool: &quot;inline-source-map&quot;, devServer: { historyApiFallback: true, hot: true, compress: true, port: 8000, },});webpack.prod.js:const { merge } = require(&quot;webpack-merge&quot;);const common = require(&quot;./webpack.common.js&quot;);const { BundleAnalyzerPlugin } = require(&quot;webpack-bundle-analyzer&quot;);module.exports = merge(common, { mode: &quot;production&quot;, devServer: { static: &quot;./dist&quot;, historyApiFallback: true, hot: true, compress: true, port: 9000, }, plugins: [ new BundleAnalyzerPlugin({ analyzerMode: &quot;static&quot;, openAnalyzer: false, generateStatsFile: true, statsFilename: &quot;bundleStats.json&quot;, }), ],}); sourcemap 설정 종류package.json:&quot;scripts&quot;: { &quot;dev&quot;: &quot;NODE_ENV=development webpack-dev-server --config webpack.dev.js&quot;, &quot;start&quot;: &quot;NODE_ENV=production webpack-dev-server --config webpack.prod.js&quot;, &quot;build&quot;: &quot;NODE_ENV=production webpack --config webpack.prod.js&quot;},jsconfig.json:{ &quot;compilerOptions&quot;: { &quot;checkJs&quot;: false, &quot;resolveJsonModule&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;target&quot;: &quot;es2020&quot;, &quot;module&quot;: &quot;es2015&quot;, &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { /* 경로 별칭을 사용하는 경우 아래 주석을 해제하여 적절히 사용한다 */ // &quot;@components/*&quot;: [&quot;./src/components/*&quot;] } }, &quot;exclude&quot;: [ &quot;dist&quot;, &quot;node_modules&quot;, &quot;build&quot;, &quot;.vscode&quot;, &quot;.nuxt&quot;, &quot;coverage&quot;, &quot;jspm_packages&quot;, &quot;tmp&quot;, &quot;temp&quot;, &quot;bower_components&quot;, &quot;.npm&quot;, &quot;.yarn&quot; ], &quot;typeAcquisition&quot;: { &quot;enable&quot;: true }}ESLint 및 Prettier 설정 React TypeScript CheatsheetESLint 및 Prettier 설치yarn add -D @typescript-eslint/eslint-plugin @typescript-eslint/parser eslintyarn add -D prettierESLint 플러그인 설치:yarn add -D eslint-config-prettier eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-react-hooks eslint-config-airbnb-typescript @typescript-eslint/eslint-plugin @typescript-eslint/parser.eslintrc.js:module.exports = { env: { browser: true, es2021: true, node: true, jest: true, }, ignorePatterns: [&quot;*.js&quot;], extends: [ &quot;eslint:recommended&quot;, &quot;plugin:react/recommended&quot;, &quot;plugin:react-hooks/recommended&quot;, &quot;plugin:import/recommended&quot;, &quot;plugin:jsx-a11y/recommended&quot;, &quot;plugin:@typescript-eslint/recommended&quot;, &quot;plugin:@typescript-eslint/recommended-requiring-type-checking&quot;, &quot;airbnb-typescript&quot;, &quot;airbnb/hooks&quot;, &quot;prettier&quot;, ], parser: &quot;@typescript-eslint/parser&quot;, parserOptions: { ecmaFeatures: { jsx: true, }, ecmaVersion: 12, sourceType: &quot;module&quot;, project: &quot;./tsconfig.json&quot;, }, plugins: [&quot;@typescript-eslint&quot;], rules: { indent: [&quot;error&quot;, 2], &quot;no-empty&quot;: &quot;warn&quot;, &quot;no-console&quot;: &quot;warn&quot;, &quot;no-unused-vars&quot;: &quot;off&quot;, &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;], &quot;react/jsx-uses-react&quot;: &quot;off&quot;, &quot;react/react-in-jsx-scope&quot;: &quot;off&quot;, &quot;@typescript-eslint/no-unused-vars&quot;: [ &quot;error&quot;, { vars: &quot;all&quot;, args: &quot;after-used&quot;, ignoreRestSiblings: false }, ], &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;warn&quot;, // Consider using explicit annotations for object literals and function return types even when they can be inferred. &quot;@typescript-eslint/naming-convention&quot;: [ &quot;error&quot;, // Allow camelCase variables (23.2), PascalCase variables (23.8), and UPPER_CASE variables (23.10) { selector: &quot;variable&quot;, format: [&quot;camelCase&quot;, &quot;PascalCase&quot;, &quot;UPPER_CASE&quot;], }, // Allow camelCase functions (23.2), and PascalCase functions (23.8) { selector: &quot;function&quot;, format: [&quot;camelCase&quot;, &quot;PascalCase&quot;], }, // Airbnb recommends PascalCase for classes (23.3), and although Airbnb does not make TypeScript recommendations, we are assuming this rule would similarly apply to anything &quot;type like&quot;, including interfaces, type aliases, and enums { selector: &quot;typeLike&quot;, format: [&quot;PascalCase&quot;], }, ], },};참조: React TypeScript Cheatsheet Webpack으로 React + TypeScript + Styled Component + Storybook 세팅하기바벨 설치yarn add -D @babel/core @babel/preset-env @babel/preset-react @babel/plugin-transform-runtime.babelrc:{ &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;], &quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-runtime&quot;, { &quot;corejs&quot;: 3 } ] ]}Emotion 설치yarn add @emoition/react @emotion/styled @emotion/babel-plugin.babelrc:개발 환경에서만 Emotion 클래스 네임을 컴포넌트 경로로 자동 레이블링 하도록 세팅한다.{ &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;], &quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-runtime&quot;, { &quot;corejs&quot;: 3 } ], [ &quot;@emotion&quot;, { // sourceMap is on by default but source maps are dead code eliminated in production &quot;sourceMap&quot;: true, &quot;autoLabel&quot;: &quot;dev-only&quot;, &quot;labelFormat&quot;: &quot;[dirname]-[filename]-[local]&quot;, &quot;cssPropOptimization&quot;: true } ] ]}파일 작성하기index.html:&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;title&amp;gt;React Boilerplate&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;src/index.tsx:import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App&quot;;const container = document.getElementById(&quot;app&quot;);ReactDOM.render(&amp;lt;App /&amp;gt;, container);src/App.tsx:import Button from &quot;./components/Button/Button&quot;;const App = () =&amp;gt; { return &amp;lt;Button&amp;gt;버튼이닷!&amp;lt;/Button&amp;gt;;};export default App;src/components/Button/Button.tsx: cobaltinc/caple-design-system - Buttonimport React from &quot;react&quot;;export type ButtonType = &quot;basic&quot; | &quot;core&quot; | &quot;special&quot; | &quot;danger&quot; | &quot;warning&quot;;export type ButtonHtmlType = &quot;button&quot; | &quot;submit&quot; | &quot;reset&quot;;export type ButtonSizeType = &quot;tiny&quot; | &quot;small&quot; | &quot;normal&quot; | &quot;large&quot; | &quot;xlarge&quot;;export interface ButtonProps { children?: React.ReactNode; htmlType?: ButtonHtmlType; type?: ButtonType; size?: ButtonSizeType; block?: boolean; ghost?: boolean; disabled?: boolean; loading?: boolean; onClick?: React.MouseEventHandler&amp;lt;HTMLButtonElement&amp;gt;; className?: string; style?: React.CSSProperties;}export default React.forwardRef&amp;lt;HTMLButtonElement, ButtonProps&amp;gt;( ( { children, htmlType = &quot;button&quot;, type = &quot;basic&quot;, size = &quot;normal&quot;, block, ghost, disabled, loading, onClick, className = &quot;&quot;, style, ...props }, ref ) =&amp;gt; { const handleClick = (e: React.MouseEvent&amp;lt;HTMLButtonElement&amp;gt;) =&amp;gt; { if (disabled || loading) { e.preventDefault(); return; } onClick?.(e); }; return ( &amp;lt;button ref={ref} type={htmlType} style={style} disabled={disabled} onClick={handleClick} {...props} &amp;gt; 버튼 &amp;lt;/button&amp;gt; ); });src/components/Button/Button.stories.tsx:import Button from &quot;./Button&quot;;export default { title: &quot;Component/Button&quot;, component: Button,};export const Default = () =&amp;gt; { const task = { content: &quot;출근하기&quot;, complete: false, }; return &amp;lt;Button&amp;gt;버튼이닷&amp;lt;/Button&amp;gt;;};src/components/Button/IconButton.tsx:import { TransparentButton } from &quot;./Button.styles&quot;;interface IProps { children?: React.ReactNode;}const IconButton = ({ children }: IProps) =&amp;gt; { return &amp;lt;TransparentButton&amp;gt;{children}&amp;lt;/TransparentButton&amp;gt;;};export default IconButton;src/components/Button/Button.Styles.ts:import styled from &quot;@emotion/styled&quot;;export const TransparentButton = styled.button` background-color: transparent; border: none; outline: none; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);`;src/components/Button/index.ts:export { default as Button } from &quot;./Button&quot;;export { default as IconButton } from &quot;./IconButton&quot;;Storybook 설정npx sb init.storybook/main.js:스토리북에서 Emotion 패키지 경로와 경로 별칭을 이해하도록 설정한다.const path = require(&quot;path&quot;);const resolvePath = (_path) =&amp;gt; path.join(process.cwd(), _path);module.exports = { stories: [&quot;../src/**/*.stories.mdx&quot;, &quot;../src/**/*.stories.@(js|jsx|ts|tsx)&quot;], addons: [&quot;@storybook/addon-links&quot;, &quot;@storybook/addon-essentials&quot;], webpackFinal: async (config) =&amp;gt; ({ ...config, resolve: { ...config.resolve, alias: { ...config.resolve.alias, &quot;@emotion/styled&quot;: resolvePath(&quot;node_modules/@emotion/styled&quot;), /* 경로 별칭을 사용하는 경우 아래 주석을 해제하여 적절하게 사용한다 */ // &quot;@components&quot;: resolvePath(&quot;src/components&quot;), }, }, }),};See also TSConfig react-jsx: 리액트 17에서 도입된 새로운 JSX 변환 React TypeScript Cheatsheet - Troubleshooting Handbook: tsconfig.json ESLint TypeScript ESLint React TypeScript Cheatsheet cobaltinc/caple-design-system - Button Emotion Github PR - 이모션 클래스 네임을 컴포넌트 경로로 자동 레이블링 하도록 세팅 " }, { "title": "체오의 브라우저 렌더링", "url": "/posts/browser-rendering/", "categories": "TIL", "tags": "브라우저렌더링, 기술면접", "date": "2022-01-08 00:00:00 +0900", "snippet": "목표브라우저가 웹 페이지를 어떻게 그리는지 설명하고, 그에 따라 어떻게 해야 브라우저 렌더링을 최적화할 수 있는지 정리합니다.브라우저 구조graph TD A[유저 인터페이스] --&amp;gt; | URI 입력 | B[브라우저 엔진] B --&amp;gt; | URI 전달 | C[렌더링 엔진] G[&quot;자료 저장소&amp;lt;/br&amp;gt;(로컬스토리지, 쿠키)&quot;] C --&amp;gt; | URI에 대한 HTTP 요청 및 응답 처리 | D[네트워크] C --&amp;gt; | 자바스크립트 파싱 | E[자바스크립트 엔진] C --&amp;gt; | 렌더 트리 그리기 | F[UI 백엔드]브라우저 렌더링 시나리오 유저 인터페이스: 사용자가 유저 인터페이스에 있는 주시표시줄에 URI를 입력합니다. 브라우저 엔진: 브라우저 엔진은 URI에 해당하는 자료를 네트워크에 요청하기 전에 자료 저장소에 캐시되어 있는지 찾고, 있다면 해당 자료를 URI와 함께 렌더링 엔진에 전달합니다. 렌더링 엔진: 렌더링 엔진은 사용자가 입력한 URI에 해당하는 자료를 네트워크에 요청하고, 응답으로 HTML, CSS, JS 리소스를 받아옵니다. HTML과 CSS는 렌더링 엔진에서 직접 파싱하고 JS 파일은 크롬의 V8 같은 자바스크립트 엔진으로 파싱합니다. 파싱 결과물인 DOM 트리를 렌더 트리로 바꿉니다. 렌더 트리를 UI 백엔드에 전달하고 UI 백엔드의 도움으로 화면을 그립니다.렌더링 과정HTML, CSS, JS 파일을 받아서 화면에 픽셀로 그리는 단계를 주요 렌더링 경로(Critical Rendering Path, CRP)라고 부르며 다음과 같은 과정을 거칩니다:graph LR A[HTML] --&amp;gt; | 파싱 | B[DOM Tree] C[CSS] --&amp;gt; | 파싱 | D[CSSOM Tree] B --&amp;gt; E[어태치먼트] D --&amp;gt; E E --&amp;gt; F[렌더 트리] F --&amp;gt; | 기하학적 요소 계산 &amp;lt;/br&amp;gt; box model, position, &amp;lt;/br&amp;gt; width, height | G[레이아웃] G --&amp;gt; | 픽셀 채우기 &amp;lt;/br&amp;gt; visibility, outline, &amp;lt;/br&amp;gt; background-color | H[페인트] H --&amp;gt; | 렌더 레이어를 &amp;lt;/br&amp;gt; 순서에 맞게 합성 | I[컴포지션] 어태치먼트: HTML과 CSS를 파싱하여 렌더 트리를 구축합니다. 렌더 트리: 렌더 트리에는 화면에 그릴 요소만 포함됩니다. 가령, display: none 속성을 가진 노드는 렌더 트리에 포함되지 않습니다. 레이아웃: 렌더 트리에 있는 각 노드를 화면 어디에 배치할지 정확한 위치와 크기 같은 기하학적 속성을 계산합니다. 웹킷(webkit)에서는 레이아웃(Layout)이라고 부르고 Gecko에서는 리플로우(Reflow)라고 부릅니다. 페인트: 배치가 끝나면 렌더 트리를 순회하면서 개별 노드에 대한 픽셀을 채웁니다. 페인트 과정은 일반적으로 페인팅 영역을 나눠서 다수의 레이어에서 수행합니다. 리페인트(Repaint)라고도 부릅니다. 컴포지션: 여러 레이어 중에서 어떤 순서부터 그려야 할지 고려하여 최종적으로 합성합니다.주요 렌더링 과정 최적화DOM 트리나 CSSOM 트리가 변경되면 렌더링을 다시 해야 하므로 레이아웃과 페인트 과정을 반복해야 합니다. 이러한 레이아웃이나 페인트는 모두 브라우저의 연산에 포함되고 웹 성능과 직결됩니다. 레이아웃이나 페인트 과정을 최소화하는 프로세스를 주요 렌더링 과정 최적화라고 부릅니다.graph LR A[DOM 트리 또는 CSSOM 트리 변경] --&amp;gt; | 요소의 크기나 위치가 바뀌거나 &amp;lt;/br&amp;gt; 브라우저 창 크기가 바뀌면 | B[레이아웃 &amp;lt;/br&amp;gt; Reflow] B ---&amp;gt; | 배경 이미지, 색상, 그림자 등 레이아웃 수치를 &amp;lt;/br&amp;gt; 변경하지 않는 스타일이 바뀌면 | C[페인트 &amp;lt;/br&amp;gt; Repaint] C ---&amp;gt; | 렌더 레이어만 바뀌면 | D[컴포지션 &amp;lt;/br&amp;gt; Composition]결론적으로, 레이아웃과 페인트를 모두 피하고 레이어만 변경하는 컴포지션을 유도하면 최고의 성능을 얻을 수 있습니다. 그리고 그러한 속성으로는 transform과 opacity가 있습니다. 따라서 예를 들면: 요소를 이동해야 할 때 레이아웃을 다시 계산 해야 하는 left: 30px 속성이 아니라 transform: translateX(30px) 속성을 사용합니다. 요소를 보여주거나 숨겨야 할 때 레이아웃을 다시 계산해야 하는 visibility 속성이 아니라 opacity를 사용합니다.See also Google Developers - 렌더링 성능: 주요 렌더링 경로의 각 파이프 라인 설명 Google Developers - 렌더링 트리 생성, 레이아웃 및 페인트: 주요 렌더링 과정에 대한 흐름 설명 이소정 - 브라우저 동작원리 CSS Triggers - transform: 주요 렌더링 과정과 관련된 CSS 속성 정리 James Priest’s Study Notes - Browser Rendering Optimization Youtube - Browser rendering process 1편 - Browser 구성 요소 2편 - 렌더링 엔진 동작과정 3편 - Browser rendering optimization Naver D2 - 브라우저는 어떻게 동작하는가? 소소 - 브라우저는 웹페이지를 어떻게 그리나요? - Critical Rendering Path Youtube - [10분 테코톡] 체프의 브라우저 렌더링" }, { "title": "CI가 통과하지 못할 경우 PR 머지 불가능하도록 설정하기 (feat. Github Actions)", "url": "/posts/github-required-status-check/", "categories": "TIL", "tags": "github", "date": "2021-12-12 00:00:00 +0900", "snippet": "목표Github 저장소에 브랜치 보호 규칙을 추가하여 CI를 통과하지 못한 PR은 머지할 수 없도록 설정한다. 예제 CI는 Github Actions를 사용한다 - 참고브랜치 보호 규칙브랜치 보호 규칙이란 특정 브랜치에 코드 변경을 반영하는 데 있어서 방어 시스템을 갖추는 것을 말한다. 예를 들어, PR 없이는 브랜치를 머지할 수 없게 만들 수 있다. 가령, git이나 Github에 익숙하지 않은 개발자가 프로덕션 코드의 베이스가 되는 main 브랜치를 잘못 덮어씌우는 일을 시스템을 구축하여 미연에 방지할 수 있다.Github 저장소마다 브랜치 보호 규칙을 추가할 수 있는데 자세한 설명은 Github 공식문서에 세세하게 잘 나와 있다.CI를 통과하지 못한 PR은 머지할 수 없도록 설정하기현재 Github 저장소 &amp;gt; Settings &amp;gt; Branches &amp;gt; Branch Protection Rule로서 develop 브랜치를 추가한 상태이다.여기서 develop 브랜치의 규칙을 편집(Edit)한다staus check는 Circle CI나 Travis CI 같은 외부 CI를 사용할 수도 있는데, 여기서는 기존에 만들어 둔 Github Actions를 사용한다현재 Github Actions CI 파일의 내용은 다음과 같다:name: On pull request CIon: pull_requestjobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [16.x] steps: - name: Check out repository uses: actions/checkout@v2 # ...여기서 jobs의 이름에 해당하는 build를 검색창에 입력해야 한다. Github Actions의 jobs 이름이 status check의 이름으로 등록되기 때문이다.추가가 완료되었다설정이 완료된 상태에서 PR을 업로드하면 status check로 등록한 CI가 Required로 표시되는 것을 확인할 수 있고, CI를 통과하지 못할 경우 머지 버튼이 비활성화된다:See also Github - About protected branches Github - Branch protection rule Github - Required status checks Github commnuity - mssing status checks" }, { "title": "Github Actions로 CI 구축하기 (feat. yarn)", "url": "/posts/github-actions-yarn/", "categories": "TIL", "tags": "github actions", "date": "2021-12-07 00:00:00 +0900", "snippet": "목표CI/CD 플랫폼인 Github Actions를 사용하여 린트와 테스트를 자동화할 수 있는 파이프라인을 구축한다. 브랜치에 푸시가 되면 자동으로 배포가 되는 정적 사이트(ex. netlify)를 이용할 예정이므로 빌드와 배포는 다루지 않는다.워크플로우 시작하기Github에서 제공하는 워크플로우 템플릿을 이용하면 우리가 원하는 자동화 작업의 워크플로우를 쉽게 만들 수 있다.Github 저장소에서 Actions 탭을 누르면 워크플로우 템플릿을 이용할 수 있다워크플로우 문법 파악하기Github 공식문서에 보면 다음과 같이 예제 코드가 나와 있다. 각 코드에 대한 설명은 다음과 같다:# 워크플로우 이름name: learn-github-actions# 워크플로우 트리거on: [push] # push를 하면 해당 워크플로우가 자동 실행된다# 워크플로우에서 실행할 작업jobs: # 작업 이름 check-bats-version: # 작업이 실행될 환경 runs-on: ubuntu-latest # 현재 작업에서 실행할 단계별 작업 steps: - uses: actions/checkout@v2 # 사용할 액션 - uses: actions/setup-node@v2 with: node-version: &quot;14&quot; - run: npm install -g bats # 실행할 커맨드 - run: bats -v워크플로우 만들기요구사항: 패키지 매니저로서 yarn을 사용한다 워크플로우 작업 시간을 줄이기 위해 설치된 패키지 의존성을 캐시한다 린트를 실행한다 테스트를 실행한다name: Lint and test Devnity FEon: [push, pull_request]jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [16.x] # 사용할 노드 버전을 명시한다 steps: # 현재 저장소로 체크아웃 한다 - name: Check out repository uses: actions/checkout@v2 # 노드를 설치한다 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v2 with: node-version: ${{ matrix.node-version }} # yarn 캐시를 한다 - name: Get yarn cache directory path id: yarn-cache-dir-path run: echo &quot;::set-output name=dir::$(yarn cache dir)&quot; - name: Cache yarn uses: actions/cache@v2 id: yarn-cache with: path: ${{ steps.yarn-cache-dir-path.outputs.dir }} key: ${{ runner.os }}-yarn-${{ hashFiles(&#39;**/yarn.lock&#39;) }} restore-keys: | ${{ runner.os }}-yarn- # 프로젝트 의존성을 설치한다 - name: Install a project run: yarn install # 린트를 실행한다 - name: Lint run: yarn lint # 테스트를 실행한다 - name: Test run: yarn test이때 린트에서 에러가 발생하거나 테스트가 실패할 경우 해당 브랜치는 머지할 수 없게 막을 수 있다. 관련 설정은 이 글을 참조한다.Github Actions 작업이 실패할 경우 PR에서 머지를 할 수 없다는 경고 메시지가 뜬다. “안 돼. 머지시킬 생각 없어. 돌아가.”따라서 작업이 완료된 코드가 머지해도 괜찮은지에 대해 린트와 테스트 측면에서 자동으로 피드백을 받을 수 있게 된다.See also Github Actions - yarn cache example" }, { "title": "emotion ThemeProvider의 theme 타입 지정하는 방법 (feat. 자동완성)", "url": "/posts/emotion-theme-type/", "categories": "TIL, Troubleshooting", "tags": "타입스크립트, emotion", "date": "2021-12-04 00:00:00 +0900", "snippet": "💁 설명emotion의 ThemeProvider를 사용할 때 커스텀으로 추가한 theme을 사용하려고 하면 타입 오류가 발생합니다. 어떻게 해결했는지 트러블슈팅 과정을 정리합니다.문제 상황프로젝트에 일관적인 디자인을 적용하기 위해 공통으로 사용할 색상 값을 assets/theme 파일에 모아두고 사용하려고 합니다.const theme = { colors: { primary: &quot;#ffb266&quot;, fontColor: &quot;#4d5256&quot;, disabled: &quot;#c0c0c0&quot;, black: &quot;#000&quot;, white: &quot;#fff&quot;, },};export default theme;이때 새 컴포넌트에서 theme에 있는 값을 사용하려면 그때마다 theme을 import 해야 합니다.// Component Aimport theme from &quot;./assets/theme&quot;;// Component Bimport theme from &quot;./assets/theme&quot;;// Component Cimport theme from &quot;./assets/theme&quot;;// ...하지만 emotion의 ThemeProvider를 이용하면 theme 파일을 import 하지 않고도 스타일 값을 사용할 수 있습니다.import { ThemeProvider } from &quot;@emotion/react&quot;;import styled from &quot;@emotion/styled&quot;;import theme from &quot;./assets/theme&quot;;// 2. 스타일드 컴포넌트에서 props.theme으로 theme 접근 가능const Wrapper = styled.div` background-color: ${(props) =&amp;gt; props.theme.colors.primary};`;const App = () =&amp;gt; { return ( &amp;lt;ThemeProvider theme={theme}&amp;gt; {/* 1. ThemeProvider 설정 */} &amp;lt;Wrapper&amp;gt; &amp;lt;h1&amp;gt;Hello, Theme&amp;lt;/h1&amp;gt; &amp;lt;/Wrapper&amp;gt; &amp;lt;/ThemeProvider&amp;gt; );};export default App;그런데 타입 오류가 발생합니다.theme에서 타입 오류가 발생한다라이브러리에서 타입을 어떻게 정의해두었길래 오류가 나는 걸까요? emotion 라이브러리 코드를 직접 열어서 ThemeProvider 컴포넌트의 theme prop이 어떤 타입인지 살펴보겠습니다. emotion-js/emotion - theming.d.ts#L9// @emotion/react/types/theming.d.tsexport interface ThemeProviderProps { theme: Partial&amp;lt;Theme&amp;gt; | ((outerTheme: Theme) =&amp;gt; Theme); children?: React.ReactNode;}// @emotion/react/types/index.d.tsexport interface Theme {}ThemeProviderProps 인터페이스에 theme의 타입은 &amp;lt;Theme&amp;gt;입니다. 그런데 Theme 인터페이스 내부가 비어 있네요. 즉, &amp;lt;ThemeProvider theme={theme} /&amp;gt;을 사용했을 때 props.theme은 프로퍼티가 비어 있는 타입인데, (제가 임의로 정의한) colors 프로퍼티로 접근하려고 하니 타입 오류가 발생한 것입니다.해결 방법emotion 패키지에 정의된 인터페이스 Theme이 제가 사용하는 theme의 타입을 상속 받게 만들면 됩니다. Emotion 공식문서 - Define a Theme을 보면 자세히 나와 있습니다.먼저 assets/theme에서 theme 객체의 인터페이스 ITheme을 정의하고 내보냅니다.const theme = { colors: { primary: &quot;#ffb266&quot;, fontColor: &quot;#4d5256&quot;, disabled: &quot;#c0c0c0&quot;, black: &quot;#000&quot;, white: &quot;#fff&quot;, },} as const;export default theme;export type ITheme = typeof theme;그 다음 types 디렉토리에 emotion.d.ts 파일을 만들고 @emotion/react 모듈에 존재하는 Theme 인터페이스가 아까 내보냈던 ITheme을 상속 받게 합니다.import &quot;@emotion/react&quot;;import { ITheme } from &quot;../assets/theme&quot;;declare module &quot;@emotion/react&quot; { export interface Theme extends ITheme {}} 참고로 assets/theme 파일에서 객체 theme에 as const로 타입 단언(const assertion)을 해주면, 해당 객체 내부 값의 타입을 리터럴 타입으로 추론합니다. 타입 단언을 하든 안 하든 IDE에서 props.theme에 어떤 프로퍼티가 있는지 자동완성을 잘 해줍니다. 다만 타입 단언을 하지 않으면 객체 내부의 값은 얼마든지 바뀔 수 있기 때문에 string으로 추론하여 프로퍼티 이름만 자동완성을 지원해주지만, 타입 단언을 할 경우 객체 내부의 값이 리터럴 타입으로 변경되어 프로퍼티의 값(색상 값)까지 자동완성을 해줍니다.결과자동완성이 가능하고,자동완성을 지원하며 프로퍼티 이름 뿐만 아니라 프로퍼티 값까지 알려준다더 이상 타입 에러가 발생하지 않습니다.타입 오류가 발생하지 않는다See also emotion - Define a theme with TypeScript toy-crane - Typescript에서 효과적으로 상수 관리하기" } ]
